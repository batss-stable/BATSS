[{"path":"/articles/web_only/Ingredients.html","id":"n","dir":"Articles > Web_only","previous_headings":"","what":"n","title":"Ingredients","text":"object type: vector integers length order argument prob0. description: n provides number participants completed follow treatment arm look interest. includes control intervention arms, active dropped (inactive). sum(n) therefore corresponds total number participants completed follow--date trial.","code":""},{"path":"/articles/web_only/Ingredients.html","id":"m","dir":"Articles > Web_only","previous_headings":"","what":"m","title":"Ingredients","text":"object type: integer scalar. description: m corresponds number participants randomised different groups (including control) given look. therefore needed RAR group allocation functions .","code":""},{"path":"/articles/web_only/Ingredients.html","id":"n-1","dir":"Articles > Web_only","previous_headings":"","what":"N","title":"Ingredients","text":"object type: integer scalar. description: N corresponds maximum sample size trial specified argument N batss.glm.","code":""},{"path":"/articles/web_only/Ingredients.html","id":"posterior","dir":"Articles > Web_only","previous_headings":"","what":"posterior","title":"Ingredients","text":"Depending context - efficacy, futility RAR - posterior corresponds (possibly) different probabilities takes different lengths. object type: numerical scalar. description: context, posterior corresponds (posterior) probability target parameter greater smaller (depending argument 'alternative' [batss.glm]) ‘delta.eff’. object type: numerical scalar. description: context, posterior corresponds (posterior) probability target parameter greater smaller (depending argument 'alternative' [batss.glm]) ‘delta.fut’. object type: numerical vector length ‘number active target parameters’ given look. description: context, posterior corresponds vector (posterior) probabilities active target parameters greater smaller (depending argument 'alternative' [batss.glm]) ‘delta.RAR’.","code":""},{"path":"/articles/web_only/Ingredients.html","id":"active","dir":"Articles > Web_only","previous_headings":"","what":"active","title":"Ingredients","text":"object type: vector length order 'prob0'. description: active indicates different arms (including control group) active (TRUE) (FALSE) look interest.","code":""},{"path":"/articles/web_only/Ingredients.html","id":"ref","dir":"Articles > Web_only","previous_headings":"","what":"ref","title":"Ingredients","text":"object type: vector length order 'prob0'. description: ref indicates group reference one (TRUE). typically first one reference group typically dropped position 1 'prob0'.","code":""},{"path":"/articles/web_only/Ingredients.html","id":"prob","dir":"Articles > Web_only","previous_headings":"","what":"prob","title":"Ingredients","text":"object type: named numerical vector length ‘number active arms (including reference group)’. description: prob output -defined function provided ‘RAR’ used defining vector allocation ratios probabilities active arms (including reference group). Note , RAR = NULL, prob equals prob0 (appropriate subsetting arms dropped).","code":""},{"path":"/articles/web_only/Ingredients.html","id":"eff-target","dir":"Articles > Web_only","previous_headings":"","what":"eff.target","title":"Ingredients","text":"object type: vector length argument (.e., number target parameters) description: eff.target indicates efficacy reached target parameter stage interest .","code":""},{"path":"/articles/web_only/Ingredients.html","id":"fut-target","dir":"Articles > Web_only","previous_headings":"","what":"fut.target","title":"Ingredients","text":"object type: vector length argument (.e., number target parameters) description: fut.target indicates futility declared target parameter stage interest .","code":""},{"path":"/articles/web_only/Priors.html","id":"introduction","dir":"Articles > Web_only","previous_headings":"","what":"Introduction","title":"Prior distributions","text":"Laplace approximation provides analytical method estimate posterior distribution parameters complex models assuming posterior distributions can approximated Gaussian densities centered mode (maximum). calculation integrals related posteriors therefore greatly simplified, typically leading computational gain, especially complex models. R several implementations Laplace approximations Bayesian inference, TMB (Template Model Builder), LaplacesDemon mgcv packages, example. BATSS builds integrated nested Laplace approximation (INLA) R-INLA, implementation R. INLA methodology focuses models can expressed latent Gaussian Markov random fields (GMRF). Consider model ηi=g(μi)=α+∑j=1pβjzij+∑k=1qfk(uik)+ϵi\\eta_i = g(\\mu_i) = \\alpha + \\sum_{j=1}^p \\beta_j z_{ij} + \\sum_{k=1}^q f_{k}(u_{ik}) + \\epsilon_i η\\eta linear predictor, g(.)g(.) link function, β\\beta pp coefficients linear effects covariates zz, fk(.)f_{k}(.) qq unknown functions covariates uu ϵ\\epsilon unstructured terms. Latent Gaussian models subset Bayesian additive models assign Gaussian prior latent field 𝒳={α,β,f(.)}\\mathcal{X}=\\{\\alpha, \\beta, f(.)\\} 𝒳|θ∼N(0,𝒬−1(θ))\\mathcal{X}|\\theta \\sim N(0,\\mathcal{Q}^{-1}(\\theta)) 𝒬\\mathcal{Q} denotes precision matrix θ\\theta vector hyperparameters. joint density latent field, hyperparameters data π(𝒳,θ|y)∝π(θ)π(𝒳|θ)∏=1nπ(yi|(A𝒳),θ) \\pi(\\mathcal{X},\\theta|y) \\propto \\pi(\\theta)\\pi(\\mathcal{X}|\\theta)\\prod_{=1}^{n}\\pi(y_i|(\\mathcal{X})_i,\\theta) η=A𝒳\\eta=\\mathcal{X}. posterior mariginals can approximated. Refer Rue, Martino, Chopin (2009) Van Niekerk et al. (2023) details.","code":""},{"path":"/articles/web_only/Priors.html","id":"priors-for-fixed-effects","dir":"Articles > Web_only","previous_headings":"","what":"Priors for fixed effects","title":"Prior distributions","text":"Hence, priors fixed effects INLA normally distributed (default mean μ=0\\mu=0 precision τ=0.001\\tau=0.001, since σ2=1/τ\\sigma^{2}=1/{\\tau}, N(0,1000)N(0,\\,1000)). control.fixed argument inla() function allows users change μ\\mu τ\\tau. batss.glm() function allows control elements inla() function passed embedded INLA routine via ... argument. inla() differentiates intercept, mean.intercept prec.intercept, fixed effects, mean prec, e.g. control.fixed = list(mean=1) assign prior mean 11 fixed effects intercept. Individual prior means precision can set named lists control.fixed argument, e.g. control.fixed = list(prec=list(=1,B=2,default=0.1)) set prior precision 11 fixed effect , 22 fixed effect B 0.10.1 fixed effects. Take note BATSS nomenclature fixed effects combination names right hand side model argument factor levels allocation function var argument (match names vector prob0) standard model.matrix() function - first level factor ignored naming purposes reference level, e.g.  following example shows batss.glm() call without changes default prior fixed effects:","code":"y <- rnorm(30) treatment <- factor(rep(c(\"A\",\"B\",\"C\"),10)) levels(treatment) ## [1] \"A\" \"B\" \"C\" model <- y ~ treatment mm <- model.matrix(model) colnames(mm) ## [1] \"(Intercept)\" \"treatmentB\"  \"treatmentC\" efficacy.fun = function(posterior,efficacy.bound){   posterior > efficacy.bound   } group.fun = function(m,prob){   prob = abs(prob)/sum(abs(prob))   m0.g = floor(prob*m)   m0   = sum(m0.g)   factor(rep(names(prob),m0.g+rmultinom(1,m-m0,prob)),          levels=names(prob))   }   #BATSS using INLA's default normal priors, N(0,1000) sim1 = batss.glm(             model             = y ~ trt,              var               = list(y   = rnorm,                                    trt = group.fun),           var.control       = list(y = list(sd = 2)),           beta              = c(1, 1, 2),           which             = c(2:3),           R                 = 10,           N                 = 200,           interim           = list(recruited=100),           prob0             = c(C=1/3, T1=1/3, T2=1/3),           eff.arm           = efficacy.fun,           eff.arm.control   = list(efficacy.bound = 0.975),           delta.eff         = c(NA,0),           fut.arm           = NULL,           computation       = \"parallel\",           H0                = FALSE,           mc.cores          = parallel::detectCores()-1)   t(apply(sim1$H1$estimate[,3,],1,summary))  #BATSS using normal priors with N(1,4) for the fixed effect of intervention T1 and  #the intercept and N(0,4) for intervention T2 and all other fixed effects. sim2 = batss.glm(             model             = y ~ trt,              var               = list(y   = rnorm,                                    trt = group.fun),           var.control       = list(y = list(sd = 2)),           beta              = c(1, 1, 2),           which             = c(2:3),           R                 = 10,           N                 = 200,           interim           = list(recruited=100),           prob0             = c(C=1/3, T1=1/3, T2=1/3),           eff.arm           = efficacy.fun,           eff.arm.control   = list(efficacy.bound = 0.975),           delta.eff         = c(NA,0),           fut.arm           = NULL,           computation       = \"parallel\",           H0                = FALSE,           mc.cores          = parallel::detectCores()-1,           control.fixed     = list(mean.intercept=1,                                    prec.intercept=0.25,                                    mean = list(trtT1 = 1, default = 0),                                     prec = 0.25)           )    t(apply(sim2$H1$estimate[,3,],1,summary))"},{"path":"/articles/web_only/Priors.html","id":"priors-for-hyperparameters","dir":"Articles > Web_only","previous_headings":"","what":"Priors for hyperparameters","title":"Prior distributions","text":"INLA hyperparameters default priors currently available BATSS Based INLA’s defaults, family, hyperparameter associated default prior used BATSS listed Table 1 (see Simpson et al. (2017) depth description complexity priors). Detailed information can viewed typing inla.models()$likelihood$[FAMILYNAME] including default parameters, e.g. normal distribution: case normal distribution default prior hyperparameter θ=log(τ)\\theta=log(\\tau) log-gamma distribution parameters =1a=1 b=0.00005b=0.00005. change prior distribution parameters use control.family argument inla() function. Priors hyperparameters can either built-prior user-defined function. Available predefined priors INLA: change prior one predefined INLA priors simply use control.family argument inla() function. example, control.family = list(hyper = list(prec = list(prior = \"logtnormal\"))) change prior distribution precision truncated normal prior. (Note name depend hyperparameter, prec.) two options define priors predefined INLA: 1. Providing tabulated distribution via table: 2. providing function via expression: statement.","code":"INLA::inla.models()$likelihood$gaussian ## $doc ## [1] \"The Gaussian likelihoood\" ##  ## $hyper ## $hyper$theta1 ## $hyper$theta1$hyperid ## [1] 65001 ## attr(,\"inla.read.only\") ## [1] FALSE ##  ## $hyper$theta1$name ## [1] \"log precision\" ## attr(,\"inla.read.only\") ## [1] FALSE ##  ## $hyper$theta1$short.name ## [1] \"prec\" ## attr(,\"inla.read.only\") ## [1] FALSE ##  ## $hyper$theta1$output.name ## [1] \"Precision for the Gaussian observations\" ## attr(,\"inla.read.only\") ## [1] FALSE ##  ## $hyper$theta1$output.name.intern ## [1] \"Log precision for the Gaussian observations\" ## attr(,\"inla.read.only\") ## [1] FALSE ##  ## $hyper$theta1$initial ## [1] 4 ## attr(,\"inla.read.only\") ## [1] FALSE ##  ## $hyper$theta1$fixed ## [1] FALSE ## attr(,\"inla.read.only\") ## [1] FALSE ##  ## $hyper$theta1$prior ## [1] \"loggamma\" ## attr(,\"inla.read.only\") ## [1] FALSE ##  ## $hyper$theta1$param ## [1] 1e+00 5e-05 ## attr(,\"inla.read.only\") ## [1] FALSE ##  ## $hyper$theta1$to.theta ## function (x)  ## log(x) ## <bytecode: 0x11c33d5f0> ## <environment: 0x11c3399e0> ## attr(,\"inla.read.only\") ## [1] TRUE ##  ## $hyper$theta1$from.theta ## function (x)  ## exp(x) ## <bytecode: 0x11c33d708> ## <environment: 0x11c3399e0> ## attr(,\"inla.read.only\") ## [1] TRUE ##  ##  ## $hyper$theta2 ## $hyper$theta2$hyperid ## [1] 65002 ## attr(,\"inla.read.only\") ## [1] FALSE ##  ## $hyper$theta2$name ## [1] \"log precision offset\" ## attr(,\"inla.read.only\") ## [1] FALSE ##  ## $hyper$theta2$short.name ## [1] \"precoffset\" ## attr(,\"inla.read.only\") ## [1] FALSE ##  ## $hyper$theta2$output.name ## [1] \"NOT IN USE\" ## attr(,\"inla.read.only\") ## [1] FALSE ##  ## $hyper$theta2$output.name.intern ## [1] \"NOT IN USE\" ## attr(,\"inla.read.only\") ## [1] FALSE ##  ## $hyper$theta2$initial ## [1] 72.08731 ## attr(,\"inla.read.only\") ## [1] FALSE ##  ## $hyper$theta2$fixed ## [1] TRUE ## attr(,\"inla.read.only\") ## [1] FALSE ##  ## $hyper$theta2$prior ## [1] \"none\" ## attr(,\"inla.read.only\") ## [1] TRUE ##  ## $hyper$theta2$param ## numeric(0) ## attr(,\"inla.read.only\") ## [1] FALSE ##  ## $hyper$theta2$to.theta ## function (x)  ## log(x) ## <bytecode: 0x11c33d5f0> ## <environment: 0x11c3399e0> ## attr(,\"inla.read.only\") ## [1] TRUE ##  ## $hyper$theta2$from.theta ## function (x)  ## exp(x) ## <bytecode: 0x11c33d708> ## <environment: 0x11c3399e0> ## attr(,\"inla.read.only\") ## [1] TRUE ##  ##  ##  ## $survival ## [1] FALSE ##  ## $discrete ## [1] FALSE ##  ## $link ## [1] \"default\"   \"identity\"  \"logit\"     \"loga\"      \"cauchit\"   \"log\"       ## [7] \"logoffset\" ##  ## $pdf ## [1] \"gaussian\" #BATSS using normal priors with N(1,4) for the fixed effect of intervention T1 and  #the intercept and N(0,4) for intervention T2 and all other fixed effects and a  #log-gamma(0.5,0.01) prior for the log precision hyperparameter. sim3 = batss.glm(             model             = y ~ trt,              var               = list(y   = rnorm,                                    trt = group.fun),           var.control       = list(y = list(sd = 2)),           beta              = c(1, 1, 2),           which             = c(2:3),           R                 = 10,           N                 = 200,           interim           = list(recruited=100),           prob0             = c(C=1/3, T1=1/3, T2=1/3),           eff.arm           = efficacy.fun,           eff.arm.control   = list(efficacy.bound = 0.975),           delta.eff         = c(NA,0),           fut.arm           = NULL,           computation       = \"parallel\",           H0                = FALSE,           mc.cores          = parallel::detectCores()-1,           control.fixed     = list(mean.intercept=1,                                    prec.intercept=0.25,                                    mean = list(trtT1 = 1, default = 0),                                     prec = 0.25),           control.family    = list(hyper = list(prec = list(param = c(0.5,0.01))))           )    t(apply(sim3$H1$estimate[,3,],1,summary)) INLA::inla.list.models(\"prior\") ## Section [prior] ##      betacorrelation               Beta prior for the correlation           ##      dirichlet                     Dirichlet prior                          ##      expression:                   A generic prior defined using expressions ##      flat                          A constant prior                         ##      gamma                         Gamma prior                              ##      gaussian                      Gaussian prior                           ##      invalid                       Void prior                               ##      jeffreystdf                   Jeffreys prior for the doc               ##      laplace                       Laplace prior                            ##      linksnintercept               Skew-normal-link intercept-prior         ##      logflat                       A constant prior for log(theta)          ##      loggamma                      Log-Gamma prior                          ##      logiflat                      A constant prior for log(1/theta)        ##      logitbeta                     Logit prior for a probability            ##      logtgaussian                  Truncated Gaussian prior                 ##      logtnormal                    Truncated Normal prior                   ##      minuslogsqrtruncnormal        (obsolete)                               ##      mvnorm                        A multivariate Normal prior              ##      none                          No prior                                 ##      normal                        Normal prior                             ##      pc                            Generic PC prior                         ##      pc.alphaw                     PC prior for alpha in Weibull            ##      pc.ar                         PC prior for the AR(p) model             ##      pc.cor0                       PC prior correlation, basemodel cor=0    ##      pc.cor1                       PC prior correlation, basemodel cor=1    ##      pc.dof                        PC prior for log(dof-2)                  ##      pc.egptail                    PC prior for the tail in the EGP likelihood ##      pc.fgnh                       PC prior for the Hurst parameter in FGN  ##      pc.gamma                      PC prior for a Gamma parameter           ##      pc.gammacount                 PC prior for the GammaCount likelihood   ##      pc.gevtail                    PC prior for the tail in the GEV likelihood ##      pc.matern                     PC prior for the Matern SPDE             ##      pc.mgamma                     PC prior for a Gamma parameter           ##      pc.prec                       PC prior for log(precision)              ##      pc.range                      PC prior for the range in the Matern SPDE ##      pc.sn                         PC prior for the skew-normal             ##      pc.spde.GA                    (experimental)                           ##      pom                           #classes-dependent prior for the POM model ##      ref.ar                        Reference prior for the AR(p) model, p<=3 ##      rprior:                       A R-function defining the prior          ##      table:                        A generic tabulated prior                ##      wishart1d                     Wishart prior dim=1                      ##      wishart2d                     Wishart prior dim=2                      ##      wishart3d                     Wishart prior dim=3                      ##      wishart4d                     Wishart prior dim=4                      ##      wishart5d                     Wishart prior dim=5                      ##      wishartkd                     Wishart prior #BATSS with default normal priors for the fixed effects and a truncated normal prior #for the precision hyperparameter sim4 = batss.glm(             model             = y ~ trt,              var               = list(y   = rnorm,                                    trt = group.fun),           var.control       = list(y = list(sd = 2)),           beta              = c(1, 1, 2),           which             = c(2:3),           R                 = 10,           N                 = 200,           interim           = list(recruited=100),           prob0             = c(C=1/3, T1=1/3, T2=1/3),           eff.arm           = efficacy.fun,           eff.arm.control   = list(efficacy.bound = 0.975),           delta.eff         = c(NA,0),           fut.arm           = NULL,           computation       = \"parallel\",           H0                = FALSE,           mc.cores          = parallel::detectCores()-1,           control.family    = list(hyper = list(prec = list(prior = \"logtnormal\")))           )    t(apply(sim4$H1$estimate[,3,],1,summary)) #manually define the log-gamma prior # either as a 'table' loggamma.function <-  function(log_precision) {   a <- 0.05;   b <- 0.01;   precision <- exp(log_precision);   logdens <- log(b^a) - lgamma(a) + (a-1)*log_precision - b*precision;   log_jacobian <- log_precision;   return(logdens + log_jacobian) } lprec <- seq(-10, 10, len=10000) loggamma.tab <- paste(c(\"table:\", cbind(lprec, loggamma.function(lprec))),                        sep = \"\", collapse = \" \") loggamma.table <- list(prec = list(prior = loggamma.tab))  #BATSS using normal priors with N(1,4) for the fixed effect of intervention T1 and  #the intercept and N(0,4) for intervention T2 and all other fixed effects and a  #tabulated log-gamma(0.5,0.01) prior for the log precision hyperparameter. sim5 = batss.glm(             model             = y ~ trt,              var               = list(y   = rnorm,                                    trt = group.fun),           var.control       = list(y = list(sd = 2)),           beta              = c(1, 1, 2),           which             = c(2:3),           R                 = 10,           N                 = 200,           interim           = list(recruited=100),           prob0             = c(C=1/3, T1=1/3, T2=1/3),           eff.arm           = efficacy.fun,           eff.arm.control   = list(efficacy.bound = 0.975),           delta.eff         = c(NA,0),           fut.arm           = NULL,           computation       = \"parallel\",           H0                = FALSE,           mc.cores          = parallel::detectCores()-1,           control.fixed     = list(mean.intercept=1,                                    prec.intercept=0.25,                                    mean = list(trtT1 = 1, default = 0),                                     prec = 0.25),           control.family    = list(hyper = loggamma.table)           )    t(apply(sim5$H1$estimate[,3,],1,summary)) #or 'expression' loggamma = \"expression:               a = 0.5;               b = 0.01;               precision = exp(log_precision);               logdens = log(b^a) - lgamma(a) + (a-1)*log_precision - b*precision;               log_jacobian = log_precision;               return(logdens + log_jacobian);\" loggamma.expression = list(prec = list(prior = loggamma))  #BATSS using normal priors with N(1,4) for the fixed effect of intervention T1 and  #the intercept and N(0,4) for intervention T2 and all other fixed effects and a  #user-defined log-gamma(0.5,0.01) prior for the log precision hyperparameter. sim6 = batss.glm(             model             = y ~ trt,              var               = list(y   = rnorm,                                    trt = group.fun),           var.control       = list(y = list(sd = 2)),           beta              = c(1, 1, 2),           which             = c(2:3),           R                 = 10,           N                 = 200,           interim           = list(recruited=100),           prob0             = c(C=1/3, T1=1/3, T2=1/3),           eff.arm           = efficacy.fun,           eff.arm.control   = list(efficacy.bound = 0.975),           delta.eff         = c(NA,0),           fut.arm           = NULL,           computation       = \"parallel\",           H0                = FALSE,           mc.cores          = parallel::detectCores()-1,           control.fixed     = list(mean.intercept=1,                                    prec.intercept=0.25,                                    mean = list(trtT1 = 1, default = 0),                                     prec = 0.25),           control.family    = list(hyper = loggamma.expression)           )    t(apply(sim6$H1$estimate[,3,],1,summary))  #check if it matches the predefined loggamma prior t(apply(sim3$H1$estimate[,3,],1,summary))"},{"path":"/articles/web_only/Priors.html","id":"further-reading","dir":"Articles > Web_only","previous_headings":"","what":"Further reading","title":"Prior distributions","text":"details (including parametrisation distributions) examples use priors INLA (extension BATSS) can found INLA documentation inla.doc(\"[TOPIC]\") online (https://www.r-inla.org/).","code":""},{"path":[]},{"path":"/articles/web_only/ancova.html","id":"context","dir":"Articles > Web_only","previous_headings":"","what":"Context","title":"ANCOVA","text":"example motivated EMPACT trial - phase IIb randomised controlled clinical trial exploring efficacy safety psilocybin-assisted psychotherapy (PAP) treatment people diagnosed treatment resistant major depressive disorder. EMPACT Bayesian adaptive multi-arm multi-stage trial response-adaptive randomisation. compares average reversed ‘Hamilton Depression Rating Scale’ scores (R-HAM-D; large R-HAM-D correspond better outcome) one month last PAP session patients allocated experimental group compared control group. three experimental groups, treated different Psilocybin doses; control treatment consists active comparator. ANCOVA model considered account patient’s baseline R-HAM-D score, might lead efficiency gains. Indeed, required sample size detect effect can reduced factor (1−ρ)(1-\\rho), ρ\\rho correlation baseline R-HAM-D score R-HAM-D score one month. details baseline covariate adjustment methods RCTs, check, example, Shiyuan Zhang Thabane (2014).","code":""},{"path":"/articles/web_only/ancova.html","id":"design","dir":"Articles > Web_only","previous_headings":"","what":"Design","title":"ANCOVA","text":"chosen design following characteristics: treatment arms: study 4 arms: active control treatment (arm “Ctrl”) 3 (experimental) groups treated different Psilocybin doses (referred arms “D1”, “D2” “D3”). additional predictor: control baseline R-HAM-D scores (continuous predictor). R-HAM-D scores baseline assumed associated R-HAM-D score taken one month, .e., primary endpoint. alternative hypotheses: superiority trial interested demonstrating efficacy experimental arm compared shared control group. Experimental arms compared one another. interim analyses maximum sample size: begin interim analyses 50 participants completing follow-, perform interim analyses every 20 participants completing follow-thereafter. maximum sample size 130 participants total 5 looks planned. assume recruitment fairly slow trial. endpoint conditional distribution: `R-HAM-D’ scores one month assumed follow Gaussian distribution. nkjn_{kj} corresponds sample size arm kk (k=0k=0 denotes control arm) stage jj max(nkj)\\text{max}(n_{kj}) evaluated across intervention arms (.e. k>0k>0), KjK_j number active arms (excluding control) look jj, ν=0.1\\nu=0.1 tuning parameter. βk\\beta_k denotes kkth target parameter, δr=0\\delta_{r} = 0 denotes (RAR-related) clinically meaningful treatment effect value, nkjn_{kj}, sample size arm kk stage jj, NN, maximum sample size, γ=3\\gamma=3 η=1.4\\eta=1.4, two tuning parameters. Refer Gotmaker et al. (2019) details δϵ=0\\delta_{\\epsilon} = 0 denotes (efficacy-related) clinically meaningful treatment effect value, bϵ=0.0115b_{\\epsilon}=0.0115 pϵ=1.575p_{\\epsilon}=1.575 tuning parameters. δf=3\\delta_{f} = 3 denotes (futility-related) clinically meaningful treatment effect values, bf=0.05b_{f} = 0.05 cut-value used declare futility. trial stopping rule: trial run efficacy futility decision reached intervention arm, maximum sample size reached (separate stopping rules arm). Note , , tuning parameter values optimised lead suitable operating characteristics, namely, familywise error rate (FWER) 0.05 global null hypothesis, probability efficacy per arm 0.8 higher assuming difference mean 5 compared control group, probability early futility stopping per arm 0.7 H0. following, define group allocation, RAR, futility efficacy functions corresponding design described .","code":""},{"path":"/articles/web_only/ancova.html","id":"rar","dir":"Articles > Web_only","previous_headings":"Design","what":"RAR","title":"ANCOVA","text":"need generate function defines allocation probabilities patients different active arms function posterior, posterior probabilities target parameter greater delta.RAR = 0, n N, respectively sample size per arm look interest max sample size define information fraction, ref, vector logicals indicating group reference one, active, vector logicals indicating groups active look interest, relevant tuning parameters (added RAR.control batss.glm), namely γ\\gamma, η\\eta, ν\\nu, respectively call gamma, eta nu Note corresponds function RAR.trippa available BATSS package.","code":"# function trippa.fun = function(posterior,n,N,ref,active,gamma,eta,nu){   g = sum(active)   h = gamma*(sum(n)/N)^eta   prob = rep(NA,g)   # reference/control arm allocation   prob[1] = (exp(max(n[!ref])-n[ref])^nu)/(g-1)   # targets/interventions (that haven't been dropped)   prob[2:g] = (posterior^h)/(sum(posterior^h))   unlist(prob)    } # test after at the first look with two set of posterior probabilities # 1/ c(.5,.5,.5,.5,.5) # 2/ c(.5,.5,.5,.5,.6) trippa.fun(c(.5,.5,.5,.5,.5),n=c(A=10,B=10,C=10,D=10,E=10,F=10),N=16,             ref = c(TRUE,rep(FALSE,5)), active = rep(TRUE,6),             gamma=3, eta=1.4, nu=0.1)"},{"path":"/articles/web_only/ancova.html","id":"group-allocation","dir":"Articles > Web_only","previous_headings":"Design","what":"Group allocation","title":"ANCOVA","text":"need generate function randomises m participants next look according allocation ratios prob, m prob ingredients described Ingredients section prob output user-defined RAR function. treatalloc.fun first allocates largest possible number units different groups given exact target probabilities assigns randomly remaining units different groups according multinomial draws. Note corresponds function alloc.balanced available BATSS package.","code":"# function treatalloc.fun = function(m,prob){   prob = abs(prob)/sum(abs(prob))    m0.g = floor(prob*m)   m0   = sum(m0.g)   factor(rep(names(prob),m0.g+rmultinom(1,m-m0,prob)),          levels=names(prob)) } # test on m = 50 patients and equal allocation per group  table(treatalloc.fun(m=50,prob=c(Ctrl=1, D1=1, D2=1, D3=1)))"},{"path":"/articles/web_only/ancova.html","id":"arm-efficacy-stopping-rule","dir":"Articles > Web_only","previous_headings":"Design","what":"Arm efficacy stopping rule","title":"ANCOVA","text":"need generate function leads logical output (TRUE arm needs stopped efficacy FALSE otherwise) takes input ingredient posterior posterior probability target parameter greater delta.eff = 0, n N, respectively sample size per arm look interest max sample size define information fraction, additional parameters bϵb_{\\epsilon} pϵp_{\\epsilon} respectively name b.eff p.eff (needs added eff.arm.control batss.glm). Note corresponds function eff.arm.infofract available BATSS package.","code":"# function efficacy.arm.fun = function(posterior,n,N,b.eff,p.eff){   posterior > (1-(b.eff*(sum(n)/N)^p.eff)) } # test for a parameter with a posterior = 0.999 efficacy.arm.fun(0.999, n=100, N=1000, b.eff = 0.045, p.eff=1.4) # test for a parameter with a posterior = 0.95 efficacy.arm.fun(0.95, n=100, N=1000, b.eff = 0.045, p.eff=1.4)"},{"path":"/articles/web_only/ancova.html","id":"arm-futility-stopping-rule","dir":"Articles > Web_only","previous_headings":"Design","what":"Arm futility stopping rule","title":"ANCOVA","text":"need generate function leads logical output (TRUE arm needs stopped futility FALSE otherwise) takes input ingredient posterior posterior probability target parameter greater delta.fut = log(1.5), additional parameter bfb_{f} name b.fut (needs added fut.arm.control batss.glm) Note corresponds function fut.arm.simple available BATSS package.","code":"# function futility.arm.fun = function(posterior,b.fut){   posterior < b.fut } # test  futility.arm.fun(0.9, b.fut=0.1) futility.arm.fun(0.075, b.fut=0.1)"},{"path":"/articles/web_only/ancova.html","id":"trial-efficacy-and-futility-stopping-rule","dir":"Articles > Web_only","previous_headings":"Design","what":"Trial efficacy and futility stopping rule","title":"ANCOVA","text":"need generate functions , based ingredients eff.target fut.target (respectively indicating efficacy futility declared target parameter stage interest ) leads logical output equal TRUE target parameters respectively declared efficacious futile, FALSE otherwise. Note correspond functions eff.trial.fut.trial.available BATSS package used default behaviour default one function batss.glm fut.trial = NULL.","code":"# function efficacy.trial.fun = function(eff.target){   all(eff.target) }  # function futility.trial.fun = function(fut.target){   all(fut.target) }  # test  futility.trial.fun(c(D1=TRUE,D2=TRUE,D3=TRUE)) efficacy.trial.fun(c(D1=TRUE,D2=TRUE,D3=FALSE))"},{"path":"/articles/web_only/ancova.html","id":"monte-carlo-simulations","dir":"Articles > Web_only","previous_headings":"","what":"Monte Carlo Simulations","title":"ANCOVA","text":"consider three scenarios: first one control ‘baseline R-HAM-D scores’ two assume different correlation levels R-HAM-D scores baseline (predictor 4) one month (primary endpoint). Thus, primary predictor, x1x_1, 4-level treatment group factor control group reference group, secondary predictor, x2x_2, centered ‘R-HAM-D scores’ baseline. iith participant, assumed model : yi=β0+β1ι(xi1=′D1′)+β2ι(xi1=′D2′)+β3ι(xi1=′D3′)+β4[xi2−_‾x2]+ϵiy_i = \\beta_0 + \\beta_1 \\iota(x_{i1}='D1') + \\beta_2 \\iota(x_{i1}='D2') + \\beta_3 \\iota(x_{i1}='D3') + \\beta_4 [x_{i2} - \\bar_{x_{2}}] + \\epsilon_i, xipx_{ip} denotes value predictor pp participant ii, ι(.)\\iota(.) denotes indicator function equals 1 condition satisfied 0 otherwise, _‾x2\\bar_{x_{2}} denotes average ‘R-HAM-D scores’ baseline. parameterisation leads following parameter interpretation: β0\\beta_0 corresponds average ‘R-HAM-D scores’ patients baseline, well one month treatment patients “Ctrl” arm, β1\\beta_1, β2\\beta_2 β3\\beta_3 respectively correspond average shift mean R-HAM-D scores one month treatment arm (“D1”, “D2” “D3”) compared control one (“Ctrl”), β4\\beta_4 regression parameter related participant ‘R-HAM-D’ scores baseline. assume mean 5 control arm mean change control 5 intervention [β0,β1,β2,β3]T=[5,5,5,5]T[\\beta_0, \\beta_1, \\beta_2, \\beta_3]^T = [5,5,5,5]^T standard deviation response given 4-level ‘treatment’ predictor, equal 7, .e., σy=7\\sigma_y=7. controlling (centered) ‘R-HAM-D scores’ baseline, need define * value β4\\beta_4, * values σx4\\sigma_{x_4} σϵ\\sigma_{\\epsilon}, standard deviations ‘baseline R-HAM-D scores’ error term, ρ\\rho, Pearson’s correlation level centered ‘baseline R-HAM-D scores’ ‘R-HAM-D scores one month’ given 4-level ‘treatment’ predictor, equals target correlation level. achieved, ANCOVA setting, choosing values respecting following equalities: * ρ=β4σx4σy\\rho = \\beta_4 \\frac{\\sigma_{x_{4}}}{\\sigma_y}, * σy2=β42σx42+σϵ2\\sigma_y^2 = \\beta_4^2\\sigma_{x_{4}}^2+\\sigma_{\\epsilon}^2, former comes relationship (simple) linear regression Pearson’s correlation coefficient later comes law total variance.","code":""},{"path":"/articles/web_only/ancova.html","id":"scenario-0","dir":"Articles > Web_only","previous_headings":"Monte Carlo Simulations","what":"Scenario 0","title":"ANCOVA","text":"Scenario 0, don’t correct baseline R-HAM-D scores. can note beta, regression parameter vector equals [5,5,5,5]T[5,5,5,5]^T, y generated via function rnorm well average respectively 5 reference group, 5+5 = 10 groups (contrasts type treatment used factor treatment self-defined function treatalloc.fun), target parameters (average shift mean R-HAM-D scores one month treatment arm (“D1”, “D2” “D3”) compared control arm) position 2 4 fitted coefficients obtained using formula y~group, prob0 provides (equal) allocation probabilities start trial, names groups, eff.arm fut.arm set functions defined (.e., efficacy.arm.fun futility.arm.fun), fut.trial specified therefore equal NULL (default) leads behaviour wished case, values additional parameters efficacy.arm.fun futility.arm.fun (.e., b.eff b.fut) specified eff.arm.control fut.arm.control, delta.eff delta.fut respectively set 0 3. chose low number seeds/trials (R=100) save time. Note , H0=TRUE, results global null also defined.","code":"library(BATSS) # number of trials R = 100   # simulation scenario0 = batss.glm(      model           = y~group,   var             = list(y = rnorm,                          group = treatalloc.fun),   var.control     = list(y = list(sd = 7)),    family          = \"gaussian\",   link            = \"identity\",   beta            = c(5,5,5,5),   which           = c(2:4),   R               = R,   alternative     = c(\"greater\"),   RAR             = trippa.fun,   RAR.control     = list(gamma=3,eta=1.4,nu=0.1),   delta.RAR       = 0,   prob0           = c(Ctrl=1,D1=1,D2=1,D3=1),   N               = 130,    interim         = list(recruited=list(m0=50, m=20)),   eff.arm         = efficacy.arm.fun,   delta.eff       = 0,    eff.arm.control = list(b.eff = 0.0115, p.eff=1.575),   delta.fut       = 3,    fut.arm         = futility.arm.fun,   fut.arm.control = list(b.fut = 0.05),   computation     = \"parallel\",   mc.cores        = 9,   H0              = TRUE,   extended        = 1)"},{"path":"/articles/web_only/ancova.html","id":"scenario-1","dir":"Articles > Web_only","previous_headings":"Monte Carlo Simulations","what":"Scenario 1","title":"ANCOVA","text":"Scenario 1, assume correlation 0 R-HAM-D scores baseline one month β4=0\\beta_4 = 0, σϵ=7\\sigma_{\\epsilon} = 7. corresponds unlikely scenario allowing us see drop power induced adding model predictor unrelated response Compared scenario 0, can note y, outcome vector, now depends R-HAM-D scores baseline, beta, regression parameter vector equals [5,5,5,5,0]T[5,5,5,5,0]^T, baseline generated function rnorm (without arguments var.control standard normal distribution assumed, irrelevant corresponding beta coefficient equal 0).","code":"library(BATSS) # number of trials R = 100   # simulation scenario1 = batss.glm(      model           = y~group+baseline,   var             = list(y = rnorm,                          group = treatalloc.fun,                          baseline = rnorm),   var.control     = list(y = list(sd = 7)),    family          = \"gaussian\",   link            = \"identity\",   beta            = c(5,5,5,5,0),   which           = c(2:4),   R               = R,   alternative     = c(\"greater\"),   RAR             = trippa.fun,   RAR.control     = list(gamma=3,eta=1.4,nu=0.1),   delta.RAR       = 0,   prob0           = c(Ctrl=1,D1=1,D2=1,D3=1),   N               = 130,    interim         = list(recruited=list(m0=50, m=20)),   eff.arm         = efficacy.arm.fun,   delta.eff       = 0,    eff.arm.control = list(b.eff = 0.0115, p.eff=1.575),   delta.fut       = 3,    fut.arm         = futility.arm.fun,   fut.arm.control = list(b.fut = 0.05),   computation     = \"parallel\",   mc.cores        = 9,   H0              = TRUE,   extended        = 1)"},{"path":"/articles/web_only/ancova.html","id":"scenario-2","dir":"Articles > Web_only","previous_headings":"Monte Carlo Simulations","what":"Scenario 2","title":"ANCOVA","text":"Scenario 2, assume ρ=0.6\\rho = 0.6 (value mentioned EMPACT protocol), σx4=3.5\\sigma_{x_{4}} = 3.5 still requiring σϵ=7\\sigma_{\\epsilon} = 7, β4=ρσyσx4=0.6×73.5=1.2,\\beta_4 = \\rho \\frac{\\sigma_y}{\\sigma_{x_{4}}} = 0.6 \\times \\frac{7}{3.5} = 1.2,σϵ2=σy2−β42σx42=72−1.22×3.52=5.6.\\sigma_{\\epsilon}^2 = \\sigma_y^2 - \\beta_4^2\\sigma_{x_{4}}^2 = 7^2 - 1.2^2 \\times 3.5^2 = 5.6. following code first defines values β4\\beta_4 σϵ\\sigma_{\\epsilon}, checks values simulation finally defines operating characteristics design. Compared ‘Scenario 1’, can note following differences: beta, now taking 1.2 last value instead 0, amended value standard deviation error term, standard deviation variable baseline.","code":"## ## calculate the SIGMA.e and BETA values outside of the batss.glm function ##   SIGMA.x = 3.5 SIGMA.y = 7 RHO     = 0.6 BETA    = c(5,5,5,5,RHO*SIGMA.y/SIGMA.x) SIGMA.e = sqrt(SIGMA.y^2 - BETA[5]^2*SIGMA.x^2) n       = 1e+5 X       = cbind(kronecker(matrix(1,nrow=n/4,ncol=1),cbind(1,diag(4)[,-1])),NA)  ## ## check values by simulation ##  sim.fun = function(seed, Xmat, BETA, SIGMA.x,SIGMA.e){     # seed=2     set.seed(seed)     Xmat[,5] = rnorm(nrow(Xmat),0,SIGMA.x)     e = rnorm(nrow(Xmat),0,SIGMA.e)     y = Xmat%*%BETA+e     #     fitw0 = lm.fit(Xmat[,1:4],y)     fitw1 = lm.fit(Xmat,y)     c(coef(fitw1),rho=cor(resid(fitw0),Xmat[,5]),sigma_ytot=sqrt(var(y)),       sigma_y = mean(sqrt(tapply(y,rep(1:4,nrow(Xmat)/4),var))),       sigma_e = sqrt(var(resid(fitw1)))) }  library(future.apply) plan(multisession) .idf(1:1000,\"seed\") toto = t(future_sapply(1:1000, sim.fun, Xmat=X, BETA=BETA,           SIGMA.x=SIGMA.x,SIGMA.e=SIGMA.e, future.seed=TRUE)) boxplot(toto-matrix(rep(c(BETA,RHO,NA,SIGMA.y,SIGMA.e),nrow(toto)),nrow=nrow(toto),byrow=TRUE)) abline(h=0,col=c(\"blue\"))   ## ## define operating characteristics  ##  # number of trials R = 100  # simulation scenario2 = batss.glm(      model           = y~group+baseline,   var             = list(y = rnorm,                          group = treatalloc.fun,                          baseline = rnorm),   var.control     = list(y = list(sd = SIGMA.e), baseline = list(sd = SIGMA.x)),    family          = \"gaussian\",   link            = \"identity\",   beta            = BETA,   which           = c(2:4),   R               = R,   alternative     = c(\"greater\"),   RAR             = trippa.fun,   RAR.control     = list(gamma=3,eta=1.4,nu=0.1),   delta.RAR       = 0,   prob0           = c(Ctrl=1,D1=1,D2=1,D3=1),   N               = 130,    interim         = list(recruited=list(m0=50, m=20)),   eff.arm         = efficacy.arm.fun,   delta.eff       = 0,    eff.arm.control = list(b.eff = 0.0115, p.eff=1.575),   delta.fut       = 3,    fut.arm         = futility.arm.fun,   fut.arm.control = list(b.fut = 0.05),   computation     = \"parallel\",   mc.cores        = 9,   H0              = TRUE,   extended        = 1)# 2"},{"path":"/articles/web_only/ancova.html","id":"scenario-comparison","dir":"Articles > Web_only","previous_headings":"Monte Carlo Simulations","what":"Scenario comparison","title":"ANCOVA","text":"Based simulation considering 10,000 Monte Carlo trials, Scenario 0, (estimated) FWER global null hypothesis power per arm alternative hypothesis respectively equal 0.0498 0.8011, Scenario 1, now controlling predictor associated primary endpoint, FWER slightly increases 0.0527 power per arm marginally decreases (0.7975), Scenario 2, now controlling predictor strongly associated primary endpoint, FWER slightly increases 0.0550 power per arm jumps 0.9424. suggests adding predictor little downside : * marginally reduces power endpoint new predictor associated, * strongly increases power endpoint new predictor associated, whilst maintaining reasonable FWER control.","code":""},{"path":"/articles/web_only/binomial.html","id":"context","dir":"Articles > Web_only","previous_headings":"","what":"Context","title":"Binomial endpoint","text":"example motivated Personalised Immunotherapy Platform (PIP) trial (Lo et al. 2022), phase II randomised controlled trial currently development compare immunotherapy combinations advanced melanoma patients. study aims assess effectiveness different novel drug combinations compared control arm treatment-naive patients predicted unlikely respond standard first line immunotherapy treatments. primary outcome objective response rate (ORR, .e., probability observing one/success) according Response Evaluation Criteria Solid Tumors (RECIST) (partial complete response vs stable disease progressive disease) 6 months post randomisation.","code":""},{"path":"/articles/web_only/binomial.html","id":"design","dir":"Articles > Web_only","previous_headings":"","what":"Design","title":"Binomial endpoint","text":"chosen design following characteristics: treatment arms: case study 6 treatment arms: standard care (arm “”), five drug combinations (referred arms “B”, “C”, “D”, “E” “F”). alternative hypotheses: superiority trial interested demonstrating efficacy compared standard care arm intervention arms compared one another. interim analyses maximum sample size: begin interim analyses 60 participants completing follow-, perform interim analyses every 12 participants completing follow-thereafter. maximum sample size 216 participants total 14 looks planned. endpoint conditional distribution: binary endpoint assumed follow binomial distribution. nkjn_{kj} corresponds sample size arm kk (k=0k=0 denotes control arm) stage jj max(nkj)\\text{max}(n_{kj}) evaluated across intervention arms (.e. k>0k>0), KjK_j number active arms (excluding control) look jj, ν=0.1\\nu=0.1 tuning parameter. βk\\beta_k denotes kkth target parameter (logit scale), δr=0\\delta_{r} = 0 denotes (RAR-related) clinically meaningful treatment effect value, nkjn_{kj}, sample size arm kk stage jj, NN, maximum sample size, γ=3\\gamma=3 η=1.4\\eta=1.4, two tuning parameters. Refer Gotmaker et al. (2019) details efficacy stopping rule: Stopping arms efficacy permitted interim analyses main objective adaptations drop poorly performing arms. δϵ=0\\delta_{\\epsilon} = 0 denotes (efficacy-related) clinically meaningful treatment effect value, bϵ=0.045b_{\\epsilon}=0.045 tuning parameter. δf=log(1.5)\\delta_{f} = log(1.5) denotes (futility-related) clinically meaningful treatment effect values assuming control ORR 40%, bf=0.1b_{f} = 0.1 cut-value used declare futility. trial stopping rule: trial run futility decision reached intervention arm maximum sample size reached. Note , , tuning parameter values optimised lead suitable operating characteristics. following, define group allocation, RAR, futility efficacy functions corresponding design described ","code":""},{"path":"/articles/web_only/binomial.html","id":"rar","dir":"Articles > Web_only","previous_headings":"Design","what":"RAR","title":"Binomial endpoint","text":"need generate function defines allocation probabilities patients different active arms function posterior, posterior probabilities target parameter greater delta.RAR = 0, n N, respectively sample size per arm look interest max sample size define information fraction, ref, vector logicals indicating group reference one, active, vector logicals indicating groups active look interest, relevant tuning parameters (added RAR.control batss.glm), namely γ\\gamma, η\\eta, ν\\nu, respectively call gamma, eta nu Note corresponds function RAR.trippa available BATSS package.","code":"# function prob.trippa = function(posterior,n,N,ref,active,gamma,eta,nu){   g = sum(active)   h = gamma*(sum(n)/N)^eta   prob = rep(NA,g)   # reference/control arm allocation   prob[1] = (exp(max(n[!ref])-n[ref])^nu)/(g-1)   # targets/interventions (that haven't been dropped)   prob[2:g] = (posterior^h)/(sum(posterior^h))   unlist(prob)    } # test after at the first look with two set of posterior probabilities # 1/ c(.5,.5,.5,.5,.5) # 2/ c(.5,.5,.5,.5,.6) prob.trippa(c(.5,.5,.5,.5,.5),n=c(A=10,B=10,C=10,D=10,E=10,F=10),N=16,             ref = c(TRUE,rep(FALSE,5)), active = rep(TRUE,6),             gamma=3, eta=1.4, nu=0.1) prob.trippa(c(.5,.5,.5,.5,.6),n=c(A=10,B=10,C=10,D=10,E=10,F=10),N=16,             ref = c(TRUE,rep(FALSE,5)), active = rep(TRUE,6),             gamma=3, eta=1.4, nu=0.1)"},{"path":"/articles/web_only/binomial.html","id":"group-allocation","dir":"Articles > Web_only","previous_headings":"Design","what":"Group allocation","title":"Binomial endpoint","text":"need generate function randomises m participants next look according allocation ratios prob, m prob ingredients described Ingredients section prob output user-defined RAR function. treatalloc.fun first allocates largest possible number units different groups given exact target probabilities assigns randomly remaining units different groups according multinomial draws. Note corresponds function alloc.balanced available BATSS package.","code":"# function treatalloc.fun = function(m,prob){   prob = abs(prob)/sum(abs(prob))    m0.g = floor(prob*m)   m0   = sum(m0.g)   factor(rep(names(prob),m0.g+rmultinom(1,m-m0,prob)),          levels=names(prob)) } # test on m = 60 patients and equal allocation per group table(treatalloc.fun(m=60,prob=c(A=1,B=1,C=1,D=1,E=1,F=1)))"},{"path":"/articles/web_only/binomial.html","id":"efficacy-rule","dir":"Articles > Web_only","previous_headings":"Design","what":"Efficacy rule","title":"Binomial endpoint","text":"need generate function leads logical output used last look trial takes input ingredient posterior posterior probability target parameter greater delta.eff = 0, additional parameter bϵb_{\\epsilon} name b.eff (needs added eff.arm.control batss.glm).","code":"# function efficacy.arm.fun = function(posterior,b.eff){   posterior > 1-b.eff  } # test for a parameter with a posterior = 0.999 efficacy.arm.fun(0.999, b.eff = 0.045) # test for a parameter with a posterior = 0.95 efficacy.arm.fun(0.95, b.eff = 0.045)"},{"path":"/articles/web_only/binomial.html","id":"arm-futility-stopping-rule","dir":"Articles > Web_only","previous_headings":"Design","what":"Arm futility stopping rule","title":"Binomial endpoint","text":"need generate function leads logical output takes input ingredient posterior posterior probability target parameter greater delta.fut = log(1.5), additional parameter bfb_{f} name b.fut (needs added fut.arm.control batss.glm) Note corresponds function fut.arm.simple available BATSS package.","code":"# function futility.arm.fun = function(posterior,b.fut){   posterior < b.fut } # test  futility.arm.fun(0.9, b.fut=0.1) futility.arm.fun(0.075, b.fut=0.1)"},{"path":"/articles/web_only/binomial.html","id":"trial-futility-stopping-rule","dir":"Articles > Web_only","previous_headings":"Design","what":"Trial futility stopping rule","title":"Binomial endpoint","text":"need generate function , based ingredient fut.target (indicating futility declared target parameter stage interest ) leads logical output equal TRUE target parameters declared futile FALSE otherwise. Note corresponds function fut.trial.available BATSS package behaviour default one function batss.glm fut.trial = NULL.","code":"# function futility.trial.fun = function(fut.target){   all(fut.target) }  # test  futility.trial.fun(c(B=TRUE,C=TRUE,D=TRUE,E=TRUE,F=TRUE)) futility.trial.fun(c(B=TRUE,C=TRUE,D=TRUE,E=TRUE,F=FALSE))"},{"path":"/articles/web_only/binomial.html","id":"monte-carlo-simulations","dir":"Articles > Web_only","previous_headings":"","what":"Monte Carlo Simulations","title":"Binomial endpoint","text":"consider two scenarios: Scenario 1: arm ORR 0.4 (global null), arms “”, “B” “C” ORR 0.4, arms “D” ORR 0.5, arms “E” “F” ORR 0.7.","code":""},{"path":"/articles/web_only/binomial.html","id":"scenario-1","dir":"Articles > Web_only","previous_headings":"Monte Carlo Simulations","what":"Scenario 1","title":"Binomial endpoint","text":"can note expit(logit(0.4)) = 0.4 reference group, logit(0.4) = -0.405 corresponds log odds ‘success’ control group, expit(logit(0.4+0)) = 0.4 groups (contrasts type treatment used factor treatment self-defined function treatalloc.fun), 0 corresponds log odds ratio value related groups “B” “F” (.e., effect), target parameters (corresponding shift ORR treatment arms “B” “F” compared “control” logit scale) position 2 6 fitted coefficients obtained using formula y~group, (equal) allocation probabilities start trial, names groups, eff.arm fut.arm set functions defined (.e., efficacy.arm.fun futility.arm.fun), delta.eff set NA 13 interim analyses 0 last look. ensures trial can’t stop early efficacy. aim achieved using strategies, like setting output function indicated eff.trial FALSE, fut.trial specified therefore equal NULL (default) leads behaviour wished case, values additional parameters efficacy.arm.fun futility.arm.fun (.e., b.eff b.fut) specified eff.arm.control fut.arm.control, delta.eff delta.fut respectively set 0 log(1.5). chose low number seeds/trials (R=25) save time.","code":"# number of trials R = 25  # logit function logit = function(p){log(p/(1 - p))}  # simulation scenario1 = batss.glm(      model           = y~group,   var             = list(y = rbinom,                          group = treatalloc.fun),   var.control     = list(y = list(size = 1)),    family          = \"binomial\",   link            = \"logit\",   beta            = c(logit(0.4), rep(0,5)),   which           = c(2:6),   R               = R,   alternative     = c(\"greater\"),   RAR             = prob.trippa,   RAR.control     = list(\"gamma\"=3, \"eta\"=1.4,\"nu\"=0.1),   delta.RAR       = 0,   prob0           = c(A=1,B=1,C=1,D=1,E=1,F=1),   N               = 216,    interim         = list(recruited=list(m0=60, m=12)),   eff.arm         = efficacy.arm.fun,   delta.eff       = c(rep(NA,13), 0),    eff.arm.control = list(b.eff = 0.045),   delta.fut       = log(1.5),    fut.arm         = futility.arm.fun,   fut.arm.control = list(b.fut = 0.1),   computation     = \"parallel\",   mc.cores        = 12,   H0              = FALSE,   extended        = 1)"},{"path":"/articles/web_only/binomial.html","id":"scenario-2","dir":"Articles > Web_only","previous_headings":"Monte Carlo Simulations","what":"Scenario 2","title":"Binomial endpoint","text":"except beta.","code":"# number of trials R = 25  # logit function logit = function(p){log(p/(1 - p))}  # simulation scenario1 = batss.glm(      model           = y~group,   var             = list(y = rbinom,                          group = treatalloc.fun),   var.control     = list(y = list(size = 1)),    family          = \"binomial\",   link            = \"logit\",   beta            = c(logit(0.4),                    # log odd of reference group                       0,0,                           # log odds ratio of groups B and C                              logit(0.5)-logit(0.4),         # log odds ratio of group D                       rep(logit(0.7)-logit(0.4),2)), # log odds ratio of groups E and F          which           = c(2:6),   R               = R,   alternative     = c(\"greater\"),   RAR             = prob.trippa,   RAR.control     = list(\"gamma\"=3, \"eta\"=1.4,\"nu\"=0.1),   delta.RAR       = 0,   prob0           = c(A=1,B=1,C=1,D=1,E=1,F=1),   N               = 216,    interim         = list(recruited=list(m0=60, m=12)),   eff.arm         = efficacy.arm.fun,   delta.eff       = c(rep(NA,13), 0),    eff.arm.control = list(b.eff = 0.045),   delta.fut       = log(1.5),    fut.arm         = futility.arm.fun,   fut.arm.control = list(b.fut = 0.1),   computation     = \"parallel\",   mc.cores        = 9,   H0              = FALSE,   extended        = 1)"},{"path":[]},{"path":"/articles/web_only/negbin.html","id":"context","dir":"Articles > Web_only","previous_headings":"","what":"Context","title":"Negative binomial endpoint","text":"case study inspired CHANGE-MS study (Curtin et al. 2016), multi-arm, phase II randomised controlled trial aimed study efficacy safety temelimab treatment relapsing-remitting multiple sclerosis (MS) determine whether temelimab slowed stopped progression MS. primary endpoint cumulative number new active lesions identified brain MRI scans performed 4 occasions (month) weeks 12-24 post-randomisation. data overdispersed (Curtin et al. 2016; Hartung et al. 2022) modelled using negative binomial GLM; use model .","code":""},{"path":"/articles/web_only/negbin.html","id":"design","dir":"Articles > Web_only","previous_headings":"","what":"Design","title":"Negative binomial endpoint","text":"chosen design following characteristics: treatment arms: case study 4 treatment arms: placebo (control), low, medium high doses temelimab (intervention arms referred arms “”, “B” “C”, respectively). alternative hypotheses: superiority trial interested demonstrating efficacy compared placebo arm intervention arms compared one another. interim analyses maximum sample size: begin interim analyses 100 participants completing follow-, perform interim analyses every 40 participants completing follow-thereafter. maximum sample size 260 participants, original study (Curtin et al. 2016). power: Similar original study, aim 90% power detect 60% reduction (RR=0.4) mean cumulative number lesions highest dose intervention arm (mean 4 (control) 1.6 lesions). endpoint conditional distribution: endpoint assumed follow negative binomial distribution nuisance parameter equal ϕ=0.5\\phi = 0.5 considering parametrisation leading following variance: Var(Y)=μ+μ2ϕ.\\text{Var}(Y) = \\mu + \\frac{\\mu^2}{\\phi}. group allocation: consider equal allocation probabilities per group (response-adaptive randomisation). βk\\beta_k denotes kkth target parameter, δϵ=0\\delta_{\\epsilon} = 0 denotes (efficacy-related) clinically meaningful treatment effect value, NN maximum sample size, nkn_k number participants completed follow arm k=1,...,Kk=1,...,K look jj (∑k=1Knk)/N(\\sum_{k=1}^{K} n_k)/N corresponds information fraction, bϵ=0.009b_{\\epsilon} = 0.009 pϵ=3p_{\\epsilon}=3 tuning parameters determine shape efficacy function (Gotmaker et al. 2019). δf=log(0.8)\\delta_{f} = log(0.8) denotes (futility-related) clinically meaningful treatment effect values, bf=0.2025b_{f} = 0.2025 cut-value used declare futility. trial stopping rule: trial run efficacy futility decision reached intervention arm maximum sample size reached. Note , , parameter values bfb_{f}, bϵb_{\\epsilon} pϵp_{\\epsilon} optimised via grid search lead suitable operating characteristics, parameters values δϵ\\delta_{\\epsilon} δf\\delta_{f} defined clinicians.","code":""},{"path":"/articles/web_only/negbin.html","id":"self-defined-r-functions","dir":"Articles > Web_only","previous_headings":"","what":"Self-defined R functions","title":"Negative binomial endpoint","text":"following, define group allocation, futility efficacy functions corresponding design described ","code":""},{"path":"/articles/web_only/negbin.html","id":"group-allocation","dir":"Articles > Web_only","previous_headings":"Self-defined R functions","what":"Group allocation","title":"Negative binomial endpoint","text":"need generate function randomises m participants next look according allocation ratios prob, m prob ingredients described Ingredients section. treatalloc.fun first allocates largest possible number units different groups given exact target probabilities assigns randomly remaining units different groups according multinomial draws. Note corresponds function alloc.balanced available BATSS package. RAR rule used, allocation probabilities used throughout trial batss.glm ones indicated prob0.","code":"# function treatalloc.fun = function(m,prob){   prob = abs(prob)/sum(abs(prob))    m0.g = floor(prob*m)   m0   = sum(m0.g)   factor(rep(names(prob),m0.g+rmultinom(1,m-m0,prob)),          levels=names(prob)) } # test on m = 40 patients and equal allocation per group table(treatalloc.fun(m=40,prob=c(control=.25,A=.25,B=.25,C=.25))) table(treatalloc.fun(m=40,prob=c(control=1,A=1,B=1,C=1)))"},{"path":"/articles/web_only/negbin.html","id":"arm-efficacy-stopping-rule","dir":"Articles > Web_only","previous_headings":"Self-defined R functions","what":"Arm efficacy stopping rule","title":"Negative binomial endpoint","text":"need generate function leads logical output takes input posterior posterior probability target parameter smaller delta.eff = 0, n N, respectively sample size per arm look interest max sample size define information fraction, bϵb_{\\epsilon} name b.eff, pϵp_{\\epsilon} name p.eff. Note correspond function eff.arm.infofract available BATSS package.","code":"# function efficacy.arm.fun = function(posterior,n,N,b.eff,p.eff){   posterior > (1-(b.eff*(sum(n)/N)^p.eff)) } # test at interim 1 for a parameter with a posterior = 0.999 efficacy.arm.fun(0.999, n=c(control=25,A=25,B=25,C=25),N=260,                  b.eff = 0.009,p.eff=3) # test at interim 1 for a parameter with a posterior = 0.9995 efficacy.arm.fun(0.9995, n=c(control=25,A=25,B=25,C=25),N=260,                  b.eff = 0.009,p.eff=3)"},{"path":"/articles/web_only/negbin.html","id":"trial-efficacy-stopping-rule","dir":"Articles > Web_only","previous_headings":"Self-defined R functions","what":"Trial efficacy stopping rule","title":"Negative binomial endpoint","text":"need generate function , based ingredient eff.target (indicating efficacy reached target parameter stage interest ) leads logical output equal TRUE target parameters reached efficacy FALSE otherwise. Note corresponds function eff.trial.available BATSS package behaviour default one function batss.glm eff.trial = NULL.","code":"# function efficacy.trial.fun = function(eff.target){   all(eff.target) }  # test  efficacy.trial.fun(c(A=TRUE,B=TRUE,C=TRUE)) efficacy.trial.fun(c(A=TRUE,B=TRUE,C=FALSE))"},{"path":"/articles/web_only/negbin.html","id":"arm-futility-stopping-rule","dir":"Articles > Web_only","previous_headings":"Self-defined R functions","what":"Arm futility stopping rule","title":"Negative binomial endpoint","text":"need generate function leads logical output takes input ingredients posterior posterior probability target parameter smaller delta.fut = log(0.8), additional parameters bfb_{f} name b.fut (needs added fut.arm.control batss.glm) Note corresponds function fut.arm.simple available BATSS package.","code":"# function futility.arm.fun = function(posterior,b.fut){   posterior < b.fut } # test  futility.arm.fun(0.9, b.fut=.2025) futility.arm.fun(0.1, b.fut=.2025)"},{"path":"/articles/web_only/negbin.html","id":"trial-futility-stopping-rule","dir":"Articles > Web_only","previous_headings":"Self-defined R functions","what":"Trial futility stopping rule","title":"Negative binomial endpoint","text":"need generate function , based ingredient fut.target (indicating futility declared target parameter stage interest ) leads logical output equal TRUE target parameters declared futile FALSE otherwise. Note corresponds function fut.trial.available BATSS package behaviour default one function batss.glm fut.trial = NULL.","code":"# function futility.trial.fun = function(fut.target){   all(fut.target) }  # test  futility.trial.fun(c(A=TRUE,B=TRUE,C=TRUE)) futility.trial.fun(c(A=TRUE,B=TRUE,C=FALSE))"},{"path":"/articles/web_only/negbin.html","id":"monte-carlo-simulations","dir":"Articles > Web_only","previous_headings":"","what":"Monte Carlo Simulations","title":"Negative binomial endpoint","text":"consider three scenarios: Scenario 1 = ‘global null’: arm cumulative mean number lesions equal 4, Scenario 2 = ‘one treatment works’: arm cumulative mean number lesions equal 4 except last one, “C”, shows 60% reduction cumulative mean number lesions compared groups (RR = 0.4), Scenario 3 = ‘better, best’: control arm cumulative mean number lesions equal 4 arms respectively lead 20%, 40% 60% reduction cumulative mean number lesions compared reference group (.e., RR = 0.8 “”, RR = 0.6 “B” RR = 0.4 “C”).","code":""},{"path":"/articles/web_only/negbin.html","id":"scenario-1","dir":"Articles > Web_only","previous_headings":"Monte Carlo Simulations","what":"Scenario 1","title":"Negative binomial endpoint","text":"can note log(4) control group, log(4)+log(1) = log(4) groups (contrasts type treatment used factor treatment self-defined function treatalloc.fun), target parameters (corresponding shift means treatment arms “”, “B” “C” compared “control” log scale) position 2, 3 4 fitted coefficients obtained using formula y~treatment, (equal) allocation probabilities throughout trial (RAR = NULL), names groups, eff.arm fut.arm set functions defined (.e., efficacy.arm.fun futility.arm.fun), eff.trial fut.trial specified therefore equal NULL (default) leads behaviour wished case, values additional parameters efficacy.arm.fun futility.arm.fun (.e., b.eff, p.eff b.fut) specified eff.arm.control fut.arm.control, delta.eff delta.fut respectively set 0 log(0.8). chose low number seeds/trials (R=25) save time.","code":"R = 25  scenario1 = batss.glm(      model           = y~treatment,   var             = list(y = rnbinom,                                    treatment = treatalloc.fun),   var.control     = list(y = list(size = 1/2)),    family          = \"nbinomial\",   link            = \"log\",   beta            = c(log(4),log(1),log(1),log(1)),   which           = c(2:4),   R               = R,   alternative     = c(\"less\"),   RAR             = NULL,   prob0           = c(control = .25, A = .25, B = .25, C = .25),   N               = 260,   interim         = list(recruited=c(100,140,180,220)),   eff.arm         = efficacy.arm.fun,   delta.eff       = 0,    eff.arm.control = list(\"b.eff\"=0.009, \"p.eff\"=3),   delta.fut       = log(0.8),    fut.arm         = futility.arm.fun,   fut.arm.control = list(\"b.fut\"=0.2025),   computation     = \"parallel\",   mc.cores        = 10,   H0              = TRUE,   extended        = 1)"},{"path":"/articles/web_only/negbin.html","id":"scenario-2","dir":"Articles > Web_only","previous_headings":"Monte Carlo Simulations","what":"Scenario 2","title":"Negative binomial endpoint","text":"except beta now leads mean exp(log(4)) = 4 control group, exp(log(4) + log(1)) = 4 (effect) groups “” “B”, exp(log(4) + log(0.4)) = 1.6 (target effect) group “C” corresponds RR 1.6/4 = 0.4.","code":"R = 25  scenario2 = batss.glm(      model           = y~treatment,   var             = list(y = rnbinom,                                    treatment = treatalloc.fun),   var.control     = list(y = list(size = 1/2)),    family          = \"nbinomial\",   link            = \"log\",   beta            = c(log(4),log(1),log(1),log(0.4)),   which           = c(2:4),   R               = R,   alternative     = c(\"less\"),   RAR             = NULL,   prob0           = c(control = .25, A = .25, B = .25, C = .25),   N               = 260,   interim         = list(recruited=c(100,140,180,220)),   eff.arm         = efficacy.arm.fun,   delta.eff       = 0,    eff.arm.control = list(\"b.eff\"=0.009, \"p.eff\"=3),   delta.fut       = log(0.8),    fut.arm         = futility.arm.fun,   fut.arm.control = list(\"b.fut\"=0.2025),   computation     = \"parallel\",   mc.cores        = 10,   H0              = TRUE,   extended        = 1)"},{"path":"/articles/web_only/negbin.html","id":"scenario-3","dir":"Articles > Web_only","previous_headings":"Monte Carlo Simulations","what":"Scenario 3","title":"Negative binomial endpoint","text":"except beta now leads mean exp(log(4)) = 4 control group, exp(log(4) + log(0.8)) = 3.2 (small effect) group “” corresponds RR 3.2/4 = 0.8, exp(log(4) + log(0.6)) = 2.4 (medium effect) group “B” corresponds RR 2.4/4 = 0.6, exp(log(4) + log(0.4)) = 1.6 (target effect) group “C” corresponds RR 1.6/4 = 0.4.","code":"R = 25  scenario3 = batss.glm(      model           = y~treatment,   var             = list(y = rnbinom,                                    treatment = treatalloc.fun),   var.control     = list(y = list(size = 1/2)),    family          = \"nbinomial\",   link            = \"log\",   beta            = c(log(4),log(0.8),log(0.6),log(0.4)),   which           = c(2:4),   R               = R,   alternative     = c(\"less\"),   RAR             = NULL,   prob0           = c(control = .25, A = .25, B = .25, C = .25),   N               = 260,   interim         = list(recruited=c(100,140,180,220)),   eff.arm         = efficacy.arm.fun,   delta.eff       = 0,    eff.arm.control = list(\"b.eff\"=0.009, \"p.eff\"=3),   delta.fut       = log(0.8),    fut.arm         = futility.arm.fun,   fut.arm.control = list(\"b.fut\"=0.2025),   computation     = \"parallel\",   mc.cores        = 10,   H0              = TRUE,   extended        = 1)"},{"path":[]},{"path":"/articles/web_only/parallelisation.html","id":"several-machines","dir":"Articles > Web_only","previous_headings":"","what":"Several machines","title":"Parallel computation","text":"Let’s assume BATSS user wants perform Monte Carlo simulation considering 10,000 trials two computers, 10 CPUs. strategy suggest consists argument computation set parallel argument mc.cores set 10 (parallel::detectCores()), number CPUs computer interest, argument extended set 1 2 (check ?batss.glm details), saving batss.glm output RData files function save name specific task computer (first last seed evaluated computer), finally, using function batss.combine combine outputs. Let’s first computer run seeds 1 5,000 save output seed1to5000.rdata: Let’s now second computer run seeds 5,001 10,000 save output seed1to5000.rdata: Transfer objects seed1to5000.rdata seed5001to10000.rdata folder computer, example path_computer1 , merge objects function batss.combine follows:","code":"require(BATSS)  ## ## run seeds 1 to 5000 (example of batss.glm) ##  seed1to5000 = batss.glm(                 model            = y ~ group,                    var              = list(y     = rnorm,                                         group = alloc.balanced),                 var.control      = list(y = list(sd = 5)),                 beta             = c(1, 1, 2),                 which            = c(2:3),                 alternative      = \"greater\",                 R                = 1:5000,                 N                = 200,                 interim          = list(recruited = seq(100, 180, 20)),                 prob0            = c(C = 1/3, T1 = 1/3, T2 = 1/3),                 eff.arm          = eff.arm.simple,                 eff.arm.control  = list(b = 0.975),                 fut.arm          = fut.arm.simple,                 fut.arm.control  = list(b = 0.05),                 computation      = \"parallel\",                 H0               = TRUE,                 mc.cores         = 10,                 extended         = 1)  ## ## save results as an rdata file ##  # specify here the folder in which to save the output path_computer1 = \"~/\" # save save(seed1to5000, file = paste0(path_computer1,\"seed1to5000.rdata\")) ## ## run seeds 5001 to 10000 (example of batss.glm) ##  seed5001to10000 = batss.glm(                 model            = y ~ group,                    var              = list(y     = rnorm,                                         group = alloc.balanced),                 var.control      = list(y = list(sd = 5)),                 beta             = c(1, 1, 2),                 which            = c(2:3),                 alternative      = \"greater\",                 R                = 5001:10000,                 N                = 200,                 interim          = list(recruited = seq(100, 180, 20)),                 prob0            = c(C = 1/3, T1 = 1/3, T2 = 1/3),                 eff.arm          = eff.arm.simple,                 eff.arm.control  = list(b = 0.975),                 fut.arm          = fut.arm.simple,                 fut.arm.control  = list(b = 0.05),                 computation      = \"parallel\",                 H0               = TRUE,                 mc.cores         = 10,                 extended         = 1)  ## ## save results as an rdata file ##  # specify here the folder in which to save the output path_computer2 = \"~/\" # save save(seed5001to10000, file = paste0(path_computer2,\"seed5001to10000.rdata\")) # combine seed1to10000 = batss.combine(     paths = paste0(path_computer1, c(\"seed1to5000\",\"seed5001to10000\"),\".rdata\"))  # look at combined results summary(seed1to10000)"},{"path":"/articles/web_only/parallelisation.html","id":"cluster","dir":"Articles > Web_only","previous_headings":"","what":"Cluster","title":"Parallel computation","text":"Let’s assume BATSS user wants perform Monte Carlo simulation considering 10,000 trials access 500 CPUs cluster. strategy suggest consists running batss.glm CPU specific subset 10,000 seeds interest specified argument R (CPU evaluates different set seeds), argument computation set sequential (parallelisation already achieved large number CPUs), saving CPU’s batss.glm output RData file using function save filenames indicating task (e.g., based first last seed evaluated CPU), using batss.combine function merge outputs single one. multiple ways accomplish . following, describe approach follow. Let us assume cluster runs Linux OS Slurm workload manager (common setup cluster computing), folder ~/batss-example// (optional) inputs, like parameters values saved RData format, R script containing user-defined functions used batss.glm (like function treatalloc.fun described ANCOVA help page) sourced CPU, folder ~/batss-example// outputs CPUs stored, optionally loads sources elements folder ~/batss-example//, runs batss.glm function set seeds assigned Slurm, saves output folder ~/batss-example// folder, R script ~/batss-example/2-combine.r, merges different 500 batss.glm outputs function batss.combine, shell script ~/batss-example/batss_sim.sh containing instructions CPU. simulation conducted : / invoking sbatch command, ii/ runs shell script ~/batss-example/batss_sim.sh CPU, iii/ starts R executes ~/batss-example/1-run.r script performs parallelised simulation, iv/ finally executing ~/batss-example/2-combine.r script merges simulation results. Let’s describe step:","code":""},{"path":"/articles/web_only/parallelisation.html","id":"sbatch-command","dir":"Articles > Web_only","previous_headings":"Cluster","what":"sbatch command","title":"Parallel computation","text":"following command corresponds Slurm sbatch submission command. submits job array task IDs 1 500 (.e., number CPUs), executing script sim_batch.sh passing (input folder) (output folder) arguments task: additional options setting maximum computation time, memory limits, email notifications, please refer help section sbatch command consult cluster’s documentation.","code":"# move to the folder of interest  cd ~/batss-example # sbatch function sbatch --array=1-500 batss_sim.sh in out"},{"path":"/articles/web_only/parallelisation.html","id":"batss_sim-sh-shell-script","dir":"Articles > Web_only","previous_headings":"Cluster","what":"batss_sim.sh shell script","title":"Parallel computation","text":"following command shell script fed sbatch call tells CPU start R (slave vanilla mode), run script 1-run.r arguments $1 $2, corresponding respectively folders specified end call sbatch, location save Rout files related task (.e., CPU job referred $SLURM_ARRAY_TASK_ID provided Slurm): files saved folder (indicated $2). Note R program may directly available via call R might need specify full path R, add shell script way make R available (like module command, example) can check cluster manager.","code":"R --slave --vanilla < 1-run.r --args $SLURM_ARRAY_TASK_ID $1 $2 > $2/${SLURM_ARRAY_TASK_ID}.Rout 2>&1"},{"path":"/articles/web_only/parallelisation.html","id":"run-r-r-script","dir":"Articles > Web_only","previous_headings":"Cluster","what":"1-run.r R script","title":"Parallel computation","text":"following code shows content R script run CPU. code loads library BATSS, defines vector seeds related job ID attributed Slurm, runs batss.glm vector seeds computation set sequential extended set 1, saves results output folder name corresponds first seed.","code":"################################### ## setup  ###################################   # load library library(BATSS)  # define list of seed for CPU to handle where # - args[1] is the job id attributed by slurm  #   that we will use as first seed # - 10000 is the number of simulations (i.e., seeds) # - 500 is the number of CPUs seed.list = seq(as.numeric(args[1]),10000,500)  # define path to in/ and out/ folders (input of sbatch) path_in  <- paste0(args[2],\"/\") path_out <- paste0(args[3],\"/\") # optionally load/source info from relevant files  # of \"in/\" here   ################################### ## simulation  ###################################  # only compute res if needed if(!any(dir(path_out)==id.seed$id[1])){     ##     ## batss.glm     ##     start = Sys.time()                             sim   = batss.glm(             model            = y ~ group,                var              = list(y     = rnorm,                                     group = alloc.balanced),             var.control      = list(y = list(sd = 5)),             beta             = c(1, 1, 2),             which            = c(2:3),             alternative      = \"greater\",             R                = seed.list,             N                = 200,             interim          = list(recruited = seq(100, 180, 20)),             prob0            = c(C = 1/3, T1 = 1/3, T2 = 1/3),             eff.arm          = eff.arm.simple,             eff.arm.control  = list(b = 0.975),             fut.arm          = fut.arm.simple,             fut.arm.control  = list(b = 0.05),             computation      = \"sequential\",             H0               = TRUE,             extended         = 1)     finish = Sys.time()      ## print required time     cat(\"\\trequired time: \",finish-start,\"\\n\\n\")      ## store results     save(sim,file=paste0(path_out,seed.list[1],\".rdata\")) }# end if  cat(\"\\n\\t\",date(),\"\\n\") cat(\"\\n\\t DONE!\\n\") q(\"no\")"},{"path":"/articles/web_only/parallelisation.html","id":"combine-r-r-script","dir":"Articles > Web_only","previous_headings":"Cluster","what":"2-combine.r R script","title":"Parallel computation","text":"simulation complete, following code merges results single object:","code":"# load library library(BATSS)  # define list of 'successful' jobs job.list = dir(\"out/\")[!grepl(\"Rout\",dir(\"out/\"))]  # list of potential 'unsuccessful' slurm jobs to be  # investigated by looking at the corresponding  # 'out' (slurm) and 'Rout' (R) files seq(1,500)[is.na(match(paste0(seq(1,500),\".rdata\"),job.list))]  # merge sim = batss.combine(paste0(\"out/\",job.list))  # store results save(sim,file=paste0(\"out/full.rdata\"))"},{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Dominique-Laurent Couturier. Author, maintainer. Liz Ryan. Author. Rainer Puhr. Author. Thomas Jaki. Author. Stephane Heritier. Author.","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Couturier D, Ryan L, Puhr R, Jaki T, Heritier S (2025). BATSS: Bayesian Adaptive Trial Simulator Software (BATSS) Generalised Linear Models. R package version 1.1.0.9002, https://batss-stable.github.io/BATSS/.","code":"@Manual{,   title = {BATSS: Bayesian Adaptive Trial Simulator Software (BATSS) for Generalised Linear Models},   author = {Dominique-Laurent Couturier and Liz Ryan and Rainer Puhr and Thomas Jaki and Stephane Heritier},   year = {2025},   note = {R package version 1.1.0.9002},   url = {https://batss-stable.github.io/BATSS/}, }"},{"path":"/index.html","id":"batss-r-package-","dir":"","previous_headings":"","what":"Package description","title":"Bayesian Adaptive Trial Simulator Software (BATSS) for Generalised Linear Models","text":"BATSS - Bayesian Adaptive Trials Simulator Software - provides flexible structure fast simulation Bayesian adaptive designs clinical trials. package can used define evaluate operating characteristics Bayesian adaptive designs various different types primary outcomes (e.g., follow normal, binary, Poisson negative binomial distribution) can incorporate common types adaptations: stopping treatments (entire trial) efficacy futility, Bayesian response adaptive randomisation - based user-defined adaptation rules. important features highly modular package include: parallel processing, customisability, use cluster computer PC/Mac, adjustment covariates. INLA needs installed prior installing BATSS. instructions, visit https://www.r-inla.org/download-install install BATSS package CRAN, run install latest stable version BATSS package GitHub, run Note developement interger added package version sequence BATSS intalled via GitHub, package version breaks major.minor.patch.dev.","code":"install.packages(\"BATSS\") install.packages(\"devtools\") devtools::install_github(\"batss-stable/BATSS\")"},{"path":"/reference/BATSS.html","id":null,"dir":"Reference","previous_headings":"","what":"BATSS — BATSS","title":"BATSS — BATSS","text":"BATSS","code":""},{"path":"/reference/RAR.optimal.html","id":null,"dir":"Reference","previous_headings":"","what":"'Optimal' control allocation — RAR.optimal","title":"'Optimal' control allocation — RAR.optimal","text":"technically response adaptive keeps allocation ratio control square root active intervention arms","code":""},{"path":"/reference/RAR.optimal.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"'Optimal' control allocation — RAR.optimal","text":"","code":"RAR.optimal(active)"},{"path":"/reference/RAR.optimal.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"'Optimal' control allocation — RAR.optimal","text":"active 'BATSS' ingredient 'active' corresponding logical vector length order 'prob0' (.e., number arms initially included study including reference group))  indicating arm active look interest.","code":""},{"path":"/reference/RAR.optimal.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"'Optimal' control allocation — RAR.optimal","text":"RAR.optimal returns vector probabilities length active.","code":""},{"path":"/reference/RAR.trippa.html","id":null,"dir":"Reference","previous_headings":"","what":"RAR of Trippa et al. (2012) — RAR.trippa","title":"RAR of Trippa et al. (2012) — RAR.trippa","text":"define group allocation probabilities based response adaptive randomisation rule Trippa et al. (2012)","code":""},{"path":"/reference/RAR.trippa.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"RAR of Trippa et al. (2012) — RAR.trippa","text":"","code":"RAR.trippa(posterior, n, N, ref, active, gamma, eta, nu)"},{"path":"/reference/RAR.trippa.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"RAR of Trippa et al. (2012) — RAR.trippa","text":"posterior 'BATSS' ingredient 'posterior' corresponding, context, (posterior) probability active target parameters greater smaller (depending argument 'alternative' batss.glm) 'delta.RAR'. n 'BATSS' ingredient 'n' corresponding vector number recruited participants per arm including control group look interest. N 'BATSS' ingredient '`N' corresponding maximum (planned) sample size. ref 'BATSS' ingredient 'ref' corresponding logical vector length order 'prob0' (.e., number arms initially included study including reference group)) indicating group reference one. active 'BATSS' ingredient 'active' corresponding logical vector length order 'prob0' (.e., number arms initially included study including reference group))  indicating arm active look interest. gamma scaling factor (defined RAR.arm.control). eta scaling factor (defined RAR.arm.control). nu scaling factor (defined RAR.arm.control).","code":""},{"path":"/reference/RAR.trippa.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"RAR of Trippa et al. (2012) — RAR.trippa","text":"RAR.trippa returns vector probabilities length active.","code":""},{"path":"/reference/alloc.balanced.html","id":null,"dir":"Reference","previous_headings":"","what":"Balanced allocation function — alloc.balanced","title":"Balanced allocation function — alloc.balanced","text":"alloc.balanced first allocates largest possible number units different groups given exact target probabilities assigns randomly remaining units different groups according multinomial draws. method leads observed allocation probabilities matching target ones m*prob integer group observed allocation probabilities (average) closer target ones compared alloc.simple.","code":""},{"path":"/reference/alloc.balanced.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Balanced allocation function — alloc.balanced","text":"","code":"alloc.balanced(m, prob)"},{"path":"/reference/alloc.balanced.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Balanced allocation function — alloc.balanced","text":"m 'BATSS' ingredient 'm', scalar corresponding number participants allocated. prob 'BATSS' ingredient 'prob', named vector allocation ratios probabilities.","code":""},{"path":"/reference/alloc.balanced.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Balanced allocation function — alloc.balanced","text":"alloc.balanced returns object class factor length 'm' levels matching names vector 'prob'.","code":""},{"path":[]},{"path":"/reference/alloc.balanced.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Balanced allocation function — alloc.balanced","text":"","code":"alloc.balanced(100, prob = c(A=.4,B=.6)) #>   [1] A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A #>  [38] A A A B B B B B B B B B B B B B B B B B B B B B B B B B B B B B B B B B B #>  [75] B B B B B B B B B B B B B B B B B B B B B B B B B B #> Levels: A B table(alloc.balanced(100, prob = c(A=.4,B=.6))) #>  #>  A  B  #> 40 60  table(alloc.balanced(100, prob = c(A=.4,B=.6))) #>  #>  A  B  #> 40 60"},{"path":"/reference/alloc.simple.html","id":null,"dir":"Reference","previous_headings":"","what":"Simple allocation function — alloc.simple","title":"Simple allocation function — alloc.simple","text":"alloc.simple independently randomises unit group (.e., flips coin unit) observed allocation probabilities may far target ones. strategy often considered poor choice.","code":""},{"path":"/reference/alloc.simple.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simple allocation function — alloc.simple","text":"","code":"alloc.simple(m, prob)"},{"path":"/reference/alloc.simple.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simple allocation function — alloc.simple","text":"m 'BATSS' ingredient 'm', scalar corresponding number participants allocated. prob 'BATSS' ingredient 'prob', named vector allocation ratios probabilities.","code":""},{"path":"/reference/alloc.simple.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simple allocation function — alloc.simple","text":"alloc.simple returns object class factor length 'm' levels matching names vector 'prob'.","code":""},{"path":[]},{"path":"/reference/alloc.simple.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simple allocation function — alloc.simple","text":"","code":"alloc.simple(100, prob = c(A=.4,B=.6)) #>   [1] B B B B A A A B B B B B B B B A B A A B A A B B A A B B B A B B A A B B A #>  [38] B A A B A A A A B B B B B B A B A B B A B B B B B A B B B B B B B B B B B #>  [75] A B B A B B B A B B A B A B B A A B B A B B A A B B #> Levels: A B table(alloc.simple(100, prob = c(A=.4,B=.6))) #>  #>  A  B  #> 49 51  table(alloc.simple(100, prob = c(A=.4,B=.6))) #>  #>  A  B  #> 47 53"},{"path":"/reference/batss.combine.html","id":null,"dir":"Reference","previous_headings":"","what":"Combines outputs generated by batss.glm — batss.combine","title":"Combines outputs generated by batss.glm — batss.combine","text":"Combines different evaluations batss.glm considering trial design different sets seeds. function useful evaluation Monte Carlo samples generated different seeds split sets computed different nodes/cpus. output function class 'batss' meaning usual generic functions (print, summary, plot) can used.","code":""},{"path":"/reference/batss.combine.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Combines outputs generated by batss.glm — batss.combine","text":"","code":"batss.combine(paths, force = FALSE)"},{"path":"/reference/batss.combine.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Combines outputs generated by batss.glm — batss.combine","text":"paths Vector indicating paths rdata files containing outputs function batss.glm considering trial design different set seeds. requires argument 'extended' function batss.glm > 0. force logical default force=FALSE. Among checks, batss.glm controls calls Monte Carlo trials combined identical stops (Note check bullet proof: check, example, able note two sets Monte Carlo trials used eff.arm function named way considered optional parameters blind fact correspond two different functions). force=TRUE forces batss.glm ignore check. useful calls differ due batss objects combined generated using different versions batss.glm.","code":""},{"path":"/reference/batss.combine.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Combines outputs generated by batss.glm — batss.combine","text":"object class 'batss'. Refer section 'Value' batss.glm details object structure.","code":""},{"path":[]},{"path":"/reference/batss.glm.html","id":null,"dir":"Reference","previous_headings":"","what":"Bayesian adaptive trial simulations for generalised linear models — batss.glm","title":"Bayesian adaptive trial simulations for generalised linear models — batss.glm","text":"Simulation Bayesian adaptive trials GLM endpoint using Integrated Nested Laplace Approximation (INLA).","code":""},{"path":"/reference/batss.glm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Bayesian adaptive trial simulations for generalised linear models — batss.glm","text":"","code":"batss.glm(   model,   var,   var.control = NULL,   family = \"gaussian\",   link = \"identity\",   beta,   which,   alternative = \"greater\",   R = 10000,   N,   interim,   prob0,   delta.eff = 0,   delta.fut = delta.eff,   delta.RAR = 0,   eff.arm,   eff.arm.control = NULL,   eff.trial = NULL,   eff.trial.control = NULL,   fut.arm,   fut.arm.control = NULL,   fut.trial = NULL,   fut.trial.control = NULL,   RAR = NULL,   RAR.control = NULL,   H0 = TRUE,   computation = \"parallel\",   mc.cores = getOption(\"mc.cores\", 3L),   extended = 0,   ... )"},{"path":"/reference/batss.glm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Bayesian adaptive trial simulations for generalised linear models — batss.glm","text":"model object class 'formula' indicating symbolic description model fitted (lm glm functions). var list. entry corresponds variable described 'model' indicates name function allowing generate variates (like rnorm rexp, example). list names match variable names unded 'model' first element correspond model outcome. grouping variable corresponding target parameters class 'factor' levels corresponding names indicated argument prob0 (see ). var.control optional list control parameters functions indicated 'var'. names list items need correspond names used 'var'. element another list names elements corresponding parameter names functions specified 'var'. family character string indicating name conditional distribution described package INLA (check inla.list.models). Default set 'gaussian'. link character string describing link function used model relate outcome set predictors: 'identity', 'log', 'logit', 'probit', 'robit', 'cauchit', 'loglog' 'cloglog' currently available options. Default set 'identity'. beta numerical vector parameter values linear predictor. length match number column X matrix induced formula indicated 'model' (check model.matrix). numerical vector indicating position target beta parameters. alternative vector strings providing one-sided direction alternative hypothesis corresponding target parameter indicated '' (order). Possibilities 'greater' (default) 'less'. vector length 1, direction used target parameter tests. R vector natural numbers used seeds (check set.seed) different Monte Carlo trials (vector length thus correspond number Monte Carlo trials). R scalar, seeds 1 R used, R corresponds number Monte Carlo trials. N scalar indicating maximum sample size. interim list parameters related interim analyses. Currently, 'recruited' available.  consists vector integers indicating number completed observations look, last excluded, increasing order. prob0 named vector initial allocation probabilities. Names need correspond levels grouping variable. RAR = NULL, probabilities/ratios used throughout (fixed allocation probabilities). delta.eff vector (length equal number looks (.e., number interims + 1)) clinically meaningful treatment effect values (linear predictor scale) used define efficacy-related posterior probabilities target parameter look. scalar provided, value used look. default delta.eff = 0. delta.fut vector (length equal number looks (.e., number interims + 1)) clinically meaningful treatment effect values (linear predictor scale) used define futility-related posterior probabilities target parameter look. scalar provided, value used look. default delta.fut = delta.eff. delta.RAR vector (length equal number looks (.e., number interims + 1)) clinically meaningful treatment effect values (linear predictor scale) used define RAR-related posterior probabilities target parameter look. scalar provided, value used interim analysis. default delta.RAR = 0. Note , vector provided, last value ignored randomisation made last look. eff.arm function defining efficacy achieved given look given information available stage given target parameter. output function must logical (length 1). Arguments function typically consider 'BATSS' ingredients. Check eff.arm.simple eff.arm.infofract examples. eff.arm.control optional list parameters function indicated 'eff.arm'. eff.trial function defining trial can stopped efficacy given output function indicated 'eff.arm'. output function must logical length one. Arguments function typically consider 'BATSS' ingredient eff.target. Check eff.trial.eff.trial.examples. eff.trial = NULL (default), trial stops efficacy target parameters found effective (like eff.trial.). eff.trial.control optional list parameters function indicated 'eff.trial'. fut.arm function defining futility achieved given look given information available stage target parameter. output function must logical (length 1). Arguments function typically consider 'BATSS' ingredients. Check fut.arm.simple see example function. fut.arm.control optional list parameters function indicated 'fut.arm'. fut.trial function defining trial can stopped futility given output function indicated 'fut.arm'. output function must logical length one. Arguments function typically consider 'BATSS' ingredient fut.target. Check fut.trial.example function. fut.trial = NULL (default), trial stops futility target parameters found futile (like fut.trial.). fut.trial.control optional list parameters function indicated 'fut.trial'. RAR function defining response-adaptive randomisation probabilities group - reference group included - group names ordering used 'prob0'. Arguments function typically consider 'BATSS' ingredients. Check RAR.trippa RAR.optimal examples. RAR = NULL (default), probabilities/ratios indicated prob0 used throughout (fixed allocation probabilities). RAR.control optional list control parameters function provided 'RAR'. H0 logical indicating whether simulation also consider case target parameters set 0 check probability rejecting hypothesis target parameter value equal 0 individually (pairwise type error) globally (family-wise error rate). Default set H0=TRUE. computation character string indicating computation performed. Possibilities 'parallel' 'sequential' default computation=\"parallel\" meaning computation split mc.cores. mc.cores integer indicating number CPUs used computation=\"parallel\" (Default 3 global 'mc.cores' global option available via getOption). extended integer indicating type results returned. 0 (default) provides summary statistics, 1 adds results Monte Carlo trial 2 additionally returns Monte Carlo dataset. batss.combine requires extended > 0 function needs merge results different sets seeds. ... Additional arguments control fitting inla.","code":""},{"path":"/reference/batss.glm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Bayesian adaptive trial simulations for generalised linear models — batss.glm","text":"function batss.glm returns S3 object class 'batss' available print/summary/plot functions beta - data frame providing information related beta parameter vector, like parameter names values, example. look - data frame providing information related looks, like sample size given interim (m) cumulative sample size given interim (n), example. par - list providing different information, like used seeds (seed) groups (group), example. H1 - list providing trial results alternative, like estimates per target parameter corresponding arm stopped (estimate), efficacy futility probabilites per target parameter overall (target, efficacy futility), sample size per group trial (sample), probabilities associated combination efficacy futility per group (scenario), detailed results per trial (trial), example. H0 - list providing trial results global null hypothesis (structure H1). call - matched call. type - type 'BATSS' analysis ('glm' currently available).","code":""},{"path":[]},{"path":"/reference/batss.glm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Bayesian adaptive trial simulations for generalised linear models — batss.glm","text":"","code":"# \\donttest{ # Example:  # * Gaussian conditional distribution with sigma = 5 # * 3 groups with group means 'C' = 1 (ref), 'T1' = 2, 'T2' = 3, #     where higher means correspond to better outcomes  # * 5 interim analyses occurring when n = 100, 120, 140, 160, and 180 # * fixed and equal allocation probabilities per arm (i.e., no RAR) # * max sample size = 200  # * efficacy stop per arm when the prob of the corresponding parameter  #     being greater than 0 is greater than 0.975 (?eff.arm.simple) # * futility stop per arm when the prob of the corresponding parameter  #     being greater than 0 is smaller than 0.05 (?fut.arm.simple)  # * trial stop once all arms have stopped (?eff.trial.all and ?fut.trial.all) #     or the max sample size was reached   sim = batss.glm(model            = y ~ group,                    var              = list(y     = rnorm,                                         group = alloc.balanced),                 var.control      = list(y = list(sd = 5)),                 beta             = c(1, 1, 2),                 which            = c(2:3),                 alternative      = \"greater\",                 R                = 20,                 N                = 200,                 interim          = list(recruited = seq(100, 180, 20)),                 prob0            = c(C = 1/3, T1 = 1/3, T2 = 1/3),                 eff.arm          = eff.arm.simple,                 eff.arm.control  = list(b = 0.975),                 fut.arm          = fut.arm.simple,                 fut.arm.control  = list(b = 0.05),                 computation      = \"parallel\",                 H0               = TRUE,                 mc.cores         = 2)# better: parallel::detectCores()-1 #>     Initialisation #>     Evaluation of H1 #>     Evaluation of H0 #>     Results # }"},{"path":"/reference/eff.arm.infofract.html","id":null,"dir":"Reference","previous_headings":"","what":"information-fraction based arm efficacy stop — eff.arm.infofract","title":"information-fraction based arm efficacy stop — eff.arm.infofract","text":"allows stopping arm efficacy given look probability corresponding target parameter greater smaller (depending argument 'alternative' batss.glm) delta.eff greater function information fraction look.","code":""},{"path":"/reference/eff.arm.infofract.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"information-fraction based arm efficacy stop — eff.arm.infofract","text":"","code":"eff.arm.infofract(posterior, b, n, N, p)"},{"path":"/reference/eff.arm.infofract.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"information-fraction based arm efficacy stop — eff.arm.infofract","text":"posterior 'BATSS' ingredient 'posterior' corresponding, context, (posterior) probability target parameter greater smaller (depending argument 'alternative' batss.glm) 'delta.eff'. b tuning parameter (defined eff.arm.control). n 'BATSS' ingredient 'n' corresponding vector number recruited participants per arm including control group. N 'BATSS' ingredient '`N' corresponding maximum (planned) sample size. p tuning parameter (defined eff.arm.control).","code":""},{"path":"/reference/eff.arm.infofract.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"information-fraction based arm efficacy stop — eff.arm.infofract","text":"eff.arm.infofract returns logical constant.","code":""},{"path":"/reference/eff.arm.simple.html","id":null,"dir":"Reference","previous_headings":"","what":"Simple arm efficacy stop — eff.arm.simple","title":"Simple arm efficacy stop — eff.arm.simple","text":"allows stopping arm efficacy given look probability corresponding target parameter greater smaller (depending argument 'alternative' batss.glm) delta.eff greater fixed value b.","code":""},{"path":"/reference/eff.arm.simple.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simple arm efficacy stop — eff.arm.simple","text":"","code":"eff.arm.simple(posterior, b)"},{"path":"/reference/eff.arm.simple.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simple arm efficacy stop — eff.arm.simple","text":"posterior 'BATSS' ingredient 'posterior' corresponding, context, (posterior) probability target parameter greater smaller (depending argument 'alternative' batss.glm) 'delta.eff'. b cut-value used declare efficacy (defined eff.arm.control).","code":""},{"path":"/reference/eff.arm.simple.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simple arm efficacy stop — eff.arm.simple","text":"eff.arm.simple returns logical constant.","code":""},{"path":"/reference/eff.trial.all.html","id":null,"dir":"Reference","previous_headings":"","what":"trial efficacy stop — eff.trial.all","title":"trial efficacy stop — eff.trial.all","text":"allows stopping trial efficacy target parameters reached efficacy look interest .","code":""},{"path":"/reference/eff.trial.all.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"trial efficacy stop — eff.trial.all","text":"","code":"eff.trial.all(eff.target)"},{"path":"/reference/eff.trial.all.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"trial efficacy stop — eff.trial.all","text":"eff.target 'BATSS' ingredient 'eff.target' corresponding logical vector length argument (.e., number target parameters) indicating efficacy reached target parameter stage previous stage.","code":""},{"path":"/reference/eff.trial.all.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"trial efficacy stop — eff.trial.all","text":"eff.trial.returns logical constant.","code":""},{"path":"/reference/eff.trial.any.html","id":null,"dir":"Reference","previous_headings":"","what":"trial efficacy stop — eff.trial.any","title":"trial efficacy stop — eff.trial.any","text":"allows stopping trial efficacy least one target parameter reached efficacy look interest.","code":""},{"path":"/reference/eff.trial.any.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"trial efficacy stop — eff.trial.any","text":"","code":"eff.trial.any(eff.target)"},{"path":"/reference/eff.trial.any.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"trial efficacy stop — eff.trial.any","text":"eff.target 'BATSS' ingredient 'eff.target' corresponding logical vector length argument (.e., number target parameters) indicating efficacy reached target parameter stage previous stage.","code":""},{"path":"/reference/eff.trial.any.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"trial efficacy stop — eff.trial.any","text":"eff.trial.returns logical constant.","code":""},{"path":"/reference/fut.arm.simple.html","id":null,"dir":"Reference","previous_headings":"","what":"arm futility stop — fut.arm.simple","title":"arm futility stop — fut.arm.simple","text":"allows stopping arm futility probability corresponding target parameter greater smaller (depending argument 'alternative' batss.glm) 'delta.fut' smaller fixed value 'b'","code":""},{"path":"/reference/fut.arm.simple.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"arm futility stop — fut.arm.simple","text":"","code":"fut.arm.simple(posterior, b)"},{"path":"/reference/fut.arm.simple.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"arm futility stop — fut.arm.simple","text":"posterior 'BATSS' ingredient 'posterior' corresponding, context, (posterior) probability target parameter greater smaller (depending argument 'alternative' batss.glm) 'delta.fut'. b cut-value used declare futility (defined fut.arm.control).","code":""},{"path":"/reference/fut.arm.simple.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"arm futility stop — fut.arm.simple","text":"fut.arm.simple returns logical constant.","code":""},{"path":"/reference/fut.trial.all.html","id":null,"dir":"Reference","previous_headings":"","what":"trial futility stop — fut.trial.all","title":"trial futility stop — fut.trial.all","text":"allows stopping trial efficacy active treatment reached futility look interest .","code":""},{"path":"/reference/fut.trial.all.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"trial futility stop — fut.trial.all","text":"","code":"fut.trial.all(fut.target)"},{"path":"/reference/fut.trial.all.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"trial futility stop — fut.trial.all","text":"fut.target 'BATSS' ingredient 'fut.target' corresponding logical vector length argument (.e., number target parameters) indicating futility declared target parameter stage previous stage.","code":""},{"path":"/reference/fut.trial.all.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"trial futility stop — fut.trial.all","text":"fut.trial.returns logical constant.","code":""},{"path":"/reference/plot.batss.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot function for 'BATSS' outputs — plot.batss","title":"Plot function for 'BATSS' outputs — plot.batss","text":"Plot objects class 'batss'","code":""},{"path":"/reference/plot.batss.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot function for 'BATSS' outputs — plot.batss","text":"","code":"# S3 method for class 'batss' plot(   x,   which = 1:4,   ask = TRUE,   hypothesis = \"H1\",   title = TRUE,   legend = TRUE,   ess = TRUE,   percentage = TRUE,   col = c(\"#008B0040\", \"#8B3A3A40\", \"#8B897040\", \"#FF990075\"),   smooth = 1,   ... )"},{"path":"/reference/plot.batss.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot function for 'BATSS' outputs — plot.batss","text":"x object class 'batss' (.e., output function batss.glm). integer vector indicating list desired plots. subset plots required, specify subset numbers 1:4. default, plots provided, .e., =1:4. Plot 1 displays boxplot total sample size well boxplot sample sizes per group, Plot 2 displays barplot probability stopping look, plot 3 displays violin plot sample size per group, plot 4 displays Monte Carlo trial target estimates function sample size. ask logical. TRUE, user prompted hit Enter key plot. See par(ask=.). default ask=TRUE. hypothesis character string indicating alternative hypothesis use analyses considering \"H0\" \"H1\", options \"H1\" (default) \"H0\". title Either logical indicating title added string (class character) indicating title added. title equals TRUE (default), title ''H1' ''H0' (depending argument hypothesis) added outer margin plot. outer margin space added title = FALSE. legend logical (default set TRUE) legend added bottom plots 3 4, list names height, cex pt respectively indicating / fraction plot used legend numeric (default .15), ii/ character expansion factor relative current par(\"cex\") numeric (default 1.25), iii/ expansion factor(s) points numeric (default 2). input legend = TRUE equivalent legend = c(height=.15, cex=1, pt=2). ess logical (default set TRUE) indicating expected sample size displayed plots 2, 3 4, list names col, cex bg respectively indicating / colour label character (plots 2, 3, 4), ii/ text expension level numerical value (plots 2, 3 4) iii/ background colour character (plot 3). input ess = TRUE equivalent ess = list(col=\"blue\", cex=1, bg=\"#FFD70070\"). percentage logical (default set TRUE) indicating probability stopping look displayed plots 2 (percentage), list names col, cex indicating / colour label character, ii/ text expension level numerical value. input percentage = TRUE equivalent percentage = list(col=\"violet\", cex=1). col vector length 4 specifying colours used. Default c(\"#8B897040\",\"#008B0040\",\"#8B3A3A40\",\"#FF990075\") last two digits hexadecimal strings specify level transparency. Refer Section 'colour specification' par details. length col equals 1, colour used cases. plots 1 2, 3rd colour vector col used display barplot boxplots. smooth numerical (>0) indictating level smoothing violin plots (plot 3). Default 1. smooth=NULL, smoothing value optimised sm.density function. ... Additional arguments affecting plot produced, like ylim ylab.","code":""},{"path":"/reference/plot.batss.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot function for 'BATSS' outputs — plot.batss","text":"Generates graphical displays results objects class 'batss'.","code":""},{"path":[]},{"path":"/reference/print.batss.html","id":null,"dir":"Reference","previous_headings":"","what":"Print function for BATSS outputs — print.batss","title":"Print function for BATSS outputs — print.batss","text":"Print method function objects class 'batss' (.e., output function batss.glm).","code":""},{"path":"/reference/print.batss.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print function for BATSS outputs — print.batss","text":"","code":"# S3 method for class 'batss' print(x, ...)"},{"path":"/reference/print.batss.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print function for BATSS outputs — print.batss","text":"x object class 'batss'. ... Additional arguments affecting print produced.","code":""},{"path":"/reference/print.batss.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print function for BATSS outputs — print.batss","text":"Prints information objects class 'batss'.","code":""},{"path":[]},{"path":"/reference/print.summary.batss.html","id":null,"dir":"Reference","previous_headings":"","what":"Print function for objects of class 'summary.batss' — print.summary.batss","title":"Print function for objects of class 'summary.batss' — print.summary.batss","text":"Print function objects class 'summary.batss'","code":""},{"path":"/reference/print.summary.batss.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print function for objects of class 'summary.batss' — print.summary.batss","text":"","code":"# S3 method for class 'summary.batss' print(x, ...)"},{"path":"/reference/print.summary.batss.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print function for objects of class 'summary.batss' — print.summary.batss","text":"x object class 'summary.batss' (.e., output function summary used output function batss.glm). ... Additional arguments affecting summary produced.","code":""},{"path":"/reference/print.summary.batss.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print function for objects of class 'summary.batss' — print.summary.batss","text":"Prints summary objects class 'batss'.","code":""},{"path":[]},{"path":"/reference/summary.batss.html","id":null,"dir":"Reference","previous_headings":"","what":"Summary function for 'BATSS' outputs — summary.batss","title":"Summary function for 'BATSS' outputs — summary.batss","text":"Summary method function objects class 'batss'.","code":""},{"path":"/reference/summary.batss.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summary function for 'BATSS' outputs — summary.batss","text":"","code":"# S3 method for class 'batss' summary(object, extended = NULL, ...)"},{"path":"/reference/summary.batss.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summary function for 'BATSS' outputs — summary.batss","text":"object object class 'batss' (.e., output function batss.glm). extended logical indicating standard (extended = FALSE, default) extended output (extended = TRUE) returned. Default NULL case input argument extended chosen generating object batss.glm() used. ... Additional arguments affecting summary produced.","code":""},{"path":"/reference/summary.batss.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summary function for 'BATSS' outputs — summary.batss","text":"Object class 'summary.batss'.","code":""},{"path":[]},{"path":"/reference/violin.density.html","id":null,"dir":"Reference","previous_headings":"","what":"Violin plot density estimates — violin.density","title":"Violin plot density estimates — violin.density","text":"Extracts density estimates violin plot.","code":""},{"path":"/reference/violin.density.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Violin plot density estimates — violin.density","text":"","code":"violin.density(data, h = NULL)"},{"path":"/reference/violin.density.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Violin plot density estimates — violin.density","text":"data data vector. h scalar corresponding smoothing parameter.","code":""},{"path":"/reference/violin.density.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Violin plot density estimates — violin.density","text":"list coordinates corresponding density values.","code":""},{"path":[]},{"path":"/news/index.html","id":"version-110","dir":"Changelog","previous_headings":"","what":"Version 1.1.0","title":"Version 1.1.0","text":"CRAN release: 2025-09-21 works additional predictors treatment effect allows save outputs (objects class summary.batss corresponding print function) violin plot sample sizes per group, barplot probability stopping trial look Update website: new ‘ANCOVA’ ‘Parallelisation’ pages","code":""},{"path":"/news/index.html","id":"version-101","dir":"Changelog","previous_headings":"","what":"Version 1.0.1","title":"Version 1.0.1","text":"CRAN release: 2025-08-27 New website address (https://batss-stable.github.io/BATSS/)","code":""},{"path":"/news/index.html","id":"version-100","dir":"Changelog","previous_headings":"","what":"Version 1.0.0","title":"Version 1.0.0","text":"CRAN release: 2024-10-02 Improvements checks Improvements internal/generic functions","code":""},{"path":"/news/index.html","id":"version-0715","dir":"Changelog","previous_headings":"","what":"Version 0.7.15","title":"Version 0.7.15","text":"Resolution bug affecting designs single target parameter","code":""},{"path":"/news/index.html","id":"version-0714","dir":"Changelog","previous_headings":"","what":"Version 0.7.14","title":"Version 0.7.14","text":"CRAN release: 2024-07-14 Improvements functions plot.batss summary.batss related cases efficacy futility criteria simulatneously met arm Minor improvements (help pages, printed messages)","code":""},{"path":"/news/index.html","id":"version-0713","dir":"Changelog","previous_headings":"","what":"Version 0.7.13","title":"Version 0.7.13","text":"Minor improvements function plot.batss Minor changes vignette dedicated binomial endpoint","code":""},{"path":"/news/index.html","id":"version-0712","dir":"Changelog","previous_headings":"","what":"Version 0.7.12","title":"Version 0.7.12","text":"Initial release BATSS pkgdown","code":""}]
